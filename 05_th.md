
# บทเรียน: สัปดาห์ที่ 2 กันยายน 2025

**หัวข้อ: Layout**

---

## Responsive Styling (การจัดรูปแบบที่ตอบสนองได้)

แอปพลิเคชันบนอุปกรณ์พกพามีความคาดหวังที่จะต้องแสดงผลด้วยส่วนติดต่อผู้ใช้ (UI) ที่สม่ำเสมอและใช้งานง่ายในอุปกรณ์ที่หลากหลาย อุปกรณ์เหล่านี้แตกต่างกันทั้งในด้านขนาดหน้าจอ การจัดวาง (แนวตั้ง/แนวนอน) ระบบปฏิบัติการ (iOS/Android) และความหนาแน่นของพิกเซล ดังนั้นการออกแบบเลย์เอาต์จึงต้องมีทั้งคุณสมบัติ **responsive** (ตอบสนองต่อการเปลี่ยนแปลง) และ **platform-aware** (ตระหนักถึงความแตกต่างของแพลตฟอร์ม)

React Native อำนวยความสะดวกผ่านเครื่องมือดังนี้:

* **Flexbox:** โมเดลการจัดวางเชิงประกาศสำหรับกำหนดตำแหน่งของ UI components
* **Platform APIs:** เครื่องมือ เช่น `Platform.select()` เพื่อปรับแต่งสไตล์ตามแพลตฟอร์ม
* **Dimension utilities:** ฟังก์ชัน เช่น `Dimensions.get()` และ hook เช่น `useWindowDimensions()` เพื่อปรับเลย์เอาต์ขณะรันไทม์

### Core Problem (ปัญหาหลัก)

> เราจะออกแบบเลย์เอาต์ที่สามารถ **ปรับตัวอัตโนมัติ** ให้เหมาะสมกับขนาดหน้าจอและแพลตฟอร์มที่หลากหลาย โดยไม่ต้องทำซ้ำตรรกะของ UI ได้อย่างไร?

คำถามนี้เป็นแรงจูงใจในการผสานการใช้ Flexbox เข้ากับการจัดรูปแบบที่ตระหนักถึงแพลตฟอร์ม

### Why Flexbox? (เหตุผลที่เลือกใช้ Flexbox)

Flexbox เป็นระบบการจัดวางหลักของ React Native เนื่องจากสามารถ:

* ลดความจำเป็นในการกำหนดขนาดแบบตายตัว
* อนุญาตให้กระจายและห่อหุ้มคอมโพเนนต์ได้อย่างยืดหยุ่น
* สนับสนุนการจัดตำแหน่งทั้งบนแกนหลักและแกนไขว้

### Motivation for Responsiveness (แรงจูงใจของการตอบสนอง)

แอปพลิเคชันสมัยใหม่ต้องรองรับ:

* อุปกรณ์หลายขนาด (สมาร์ตโฟน แท็บเล็ต)
* การเปลี่ยนการจัดวาง (แนวตั้ง/แนวนอน)
* การคำนวณเลย์เอาต์แบบไดนามิก

การขาดความสามารถในการตอบสนองอาจนำไปสู่ปัญหา เช่น ข้อความหรือคอนเทนต์ถูกตัดขาด โครงสร้างเลย์เอาต์ผิดพลาด และการเข้าถึงที่ไม่เหมาะสม

### Key Tools in This Module (เครื่องมือสำคัญในโมดูลนี้)

* `flexDirection`, `justifyContent`, `alignItems`
* `flexWrap`, `flex` และ utilities สำหรับการเว้นระยะ
* `Dimensions.get()`, `useWindowDimensions()`
* `Platform.select()` สำหรับสไตล์เฉพาะแพลตฟอร์ม
* `SafeAreaView` สำหรับการจัดวางที่ปลอดภัยบนอุปกรณ์ที่มีรอยบาก (notches)

---

## Flexbox Fundamentals (พื้นฐาน Flexbox)

### Overview

React Native ใช้ระบบเลย์เอาต์ **Flexbox** เพื่อจัดการตำแหน่ง การจัดแนว และการกระจายคอมโพเนนต์ UI ซึ่งต่างจากการจัดวางแบบ absolute หรือแบบ grid เนื่องจาก Flexbox ช่วยให้นักพัฒนาสามารถสร้างเลย์เอาต์ที่ยืดหยุ่นและปรับขยายได้ โดยใช้หลักการชุดเดียวกันในทุกแพลตฟอร์ม

### Main Concepts (แนวคิดหลัก)

1. **flexDirection**
   ระบุทิศทางของแกนหลักที่คอมโพเนนต์ถูกจัดวาง

   * `'row'` – จากซ้ายไปขวา (แนวนอน)
   * `'column'` – จากบนลงล่าง (แนวตั้ง; ค่าเริ่มต้น)

   **ตัวอย่าง:**

   ```javascript
   <View style={{ flexDirection: 'row' }}>
     <Text>Item 1</Text>
     <Text>Item 2</Text>
   </View>
   ```

2. **justifyContent**
   จัดเรียงคอมโพเนนต์ตามแกนหลัก

   * ค่า: `'flex-start'`, `'center'`, `'flex-end'`, `'space-between'`, `'space-around'`, `'space-evenly'`

3. **alignItems**
   จัดเรียงคอมโพเนนต์ตามแกนไขว้ (ตั้งฉากกับแกนหลัก)

   * ค่า: `'flex-start'`, `'center'`, `'flex-end'`, `'stretch'`

4. **flexWrap**
   กำหนดว่าคอมโพเนนต์ควรห่อบรรทัดหรือไม่หากพื้นที่ไม่พอ

   * ค่า: `'nowrap'` (ค่าเริ่มต้น), `'wrap'`

5. **flex**
   คำสั่งย่อเพื่อกำหนดว่าคอมโพเนนต์หนึ่งควรใช้พื้นที่มากน้อยเพียงใดเมื่อเทียบกับพี่น้อง (siblings)

   * ตัวอย่าง: `flex: 1` หมายถึงคอมโพเนนต์จะใช้พื้นที่เท่ากัน หากทุกพี่น้องถูกกำหนด `flex: 1`

### Example Layout Using Flexbox

```javascript
const styles = StyleSheet.create({
  container: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
  },
  box: {
    width: 50,
    height: 50,
    backgroundColor: '#ccc',
  },
});

<View style={styles.container}>
  <View style={styles.box} />
  <View style={styles.box} />
  <View style={styles.box} />
</View>
```

### Result (ผลลัพธ์)

* กล่องสามกล่องถูกจัดเรียงในแนวนอน
* ถูกเว้นระยะอย่างเท่าเทียมบนแกนหลักด้วย `justifyContent: 'space-between'`
* ถูกจัดให้อยู่กึ่งกลางในแนวตั้งด้วย `alignItems: 'center'`

### Key Observations (ข้อสังเกตสำคัญ)

* Flexbox เป็น **dimension-independent** หมายความว่าสามารถปรับตัวได้โดยไม่ขึ้นกับขนาดหน้าจอที่แน่นอน
* เลย์เอาต์สามารถกำหนดได้ด้วยการจัดเรียงตามแกนอย่างมีเหตุผล
* ช่วยสนับสนุนรูปแบบ UI ที่สะอาด ยืดหยุ่น และนำกลับมาใช้ใหม่ได้บนทุกแพลตฟอร์ม



## Layout with Flexbox (การจัดวางด้วย Flexbox)

React Native ใช้ **Flexbox** เป็นระบบการจัดวางหลัก โดยช่วยให้นักพัฒนาสามารถออกแบบ UI ที่ตอบสนองและยืดหยุ่นได้ในหลายขนาดหน้าจอ ผ่านการควบคุมทิศทาง การจัดเรียง การห่อบรรทัด และการเว้นระยะ

### Key Flexbox Properties (คุณสมบัติสำคัญของ Flexbox)

* `flexDirection`: กำหนดทิศทางของแกนหลัก — `row` หรือ `column` (ค่าเริ่มต้น)
* `justifyContent`: จัดเรียงคอมโพเนนต์ตามแกนหลัก (`flex-start`, `center`, `space-around` ฯลฯ)
* `alignItems`: จัดเรียงคอมโพเนนต์ตามแกนไขว้ (`flex-start`, `center`, `stretch`)
* `flexWrap`: อนุญาตให้คอมโพเนนต์ห่อบรรทัดหลายแถว
* `flex`: ควบคุมการกระจายพื้นที่ระหว่างคอมโพเนนต์พี่น้อง
* `margin`, `gap`: เพิ่มการเว้นระยะระหว่างคอมโพเนนต์

---

### Flexbox Row Alignment Example (ตัวอย่างการจัดเรียงแนวนอนด้วย Flexbox)

```javascript
<View style={{ flexDirection: 'row', justifyContent: 'space-between' }}>
  <Text>Left</Text>
  <Text>Center</Text>
  <Text>Right</Text>
</View>
```

เลย์เอาต์นี้ใช้โมเดล Flexbox เพื่อจัดเรียงคอมโพเนนต์ลูกในแนวนอน

* `flexDirection: 'row'`: จัดเรียงคอมโพเนนต์ในแนวนอนจากซ้ายไปขวา
* `justifyContent: 'space-between'`: กระจายพื้นที่ระหว่างคอมโพเนนต์ให้เท่ากัน โดยตัวแรกอยู่ชิดซ้าย ตัวสุดท้ายอยู่ชิดขวา
* `<Text>...</Text>`: แทนแต่ละคอมโพเนนต์ข้อความที่จะแสดงเป็นบล็อกในเลย์เอาต์

**ผลลัพธ์เชิงภาพ:**

```
Left         Center         Right
```

รูปแบบนี้นิยมใช้กับแถบหัวข้อ (header bar) ปุ่มที่เว้นระยะเท่า ๆ กัน หรือเมนูนำทาง

---

### Responsive Two-Column Layout Example (ตัวอย่างเลย์เอาต์สองคอลัมน์ที่ตอบสนองได้)

ตัวอย่างนี้แสดงวิธีสร้างเลย์เอาต์สองคอลัมน์โดยใช้ Flexbox โดยแต่ละคอลัมน์ถูกกำหนดให้ใช้พื้นที่เท่า ๆ กัน และสามารถห่อบรรทัดเมื่อหน้าจอแคบ

```javascript
<View style={styles.container}>
  <View style={styles.column}><Text>Column 1</Text></View>
  <View style={styles.column}><Text>Column 2</Text></View>
</View>

const styles = StyleSheet.create({
  container: { flexDirection: 'row', flexWrap: 'wrap' },
  column: {
    flex: 1,
    margin: 10,
    padding: 20,
    backgroundColor: '#eee',
  },
});
```

**คำอธิบาย:**

* `flexDirection: 'row'` – จัดเรียงคอลัมน์ในแนวนอน
* `flexWrap: 'wrap'` – อนุญาตให้คอลัมน์เลื่อนไปขึ้นบรรทัดใหม่เมื่อพื้นที่จำกัด
* `flex: 1` – ทำให้แต่ละคอลัมน์ใช้พื้นที่แนวนอนเท่า ๆ กัน
* `margin`, `padding` – ควบคุมการเว้นระยะรอบนอกและภายในแต่ละคอลัมน์
* `backgroundColor: '#eee'` – เพิ่มพื้นหลังสีอ่อนเพื่อมองเห็นได้ชัดเจน

**ผลลัพธ์:**
เลย์เอาต์นี้แสดงคอลัมน์คู่กันบนหน้าจอกว้าง และซ้อนกันในแนวตั้งเมื่ออยู่บนหน้าจอแคบ เหมาะสำหรับการออกแบบ UI แบบ responsive

---

## Styling with `StyleSheet` (การกำหนดสไตล์ด้วย `StyleSheet`)

### Overview

ในการพัฒนา React Native การกำหนดสไตล์ทำได้โดยใช้วัตถุ (object) ของ JavaScript ที่เลียนแบบคุณสมบัติของ CSS วิธีที่แนะนำคือใช้ `StyleSheet.create()` ซึ่งมีข้อดีทั้งด้านประสิทธิภาพและการแยกขอบเขตของสไตล์ ช่วยเพิ่มความสามารถในการดูแลรักษาโค้ด และสนับสนุนการออกแบบ UI แบบโมดูลาร์

### Benefits of `StyleSheet.create()` (ข้อดีของ `StyleSheet.create()`)

* คอมไพล์สไตล์ไปยังโค้ด native เพื่อเพิ่มประสิทธิภาพ
* ตรวจสอบความถูกต้องของการกำหนดสไตล์ระหว่างรันไทม์
* สนับสนุนการรวมศูนย์สไตล์เพื่อการจัดการโค้ดที่เป็นระบบมากขึ้น

### Basic Example (ตัวอย่างพื้นฐาน)

```javascript
import { StyleSheet, View, Text } from 'react-native';

const styles = StyleSheet.create({
  container: {
    padding: 20,
    backgroundColor: '#f2f2f2',
  },
  text: {
    fontSize: 18,
    color: '#333',
  },
});

export default function App() {
  return (
    <View style={styles.container}>
      <Text style={styles.text}>Hello, styled world!</Text>
    </View>
  );
}
```

### Key Concepts (แนวคิดสำคัญ)

* Styles เป็นเพียงวัตถุ JavaScript
* คุณสมบัติถูกเขียนในรูปแบบ **camelCase** (เช่น `backgroundColor`, `fontSize`)
* ค่าอาจเป็นค่าคงที่ ตัวแปร หรือการคำนวณตามเงื่อนไข



## Responsive Techniques in React Native (เทคนิคการออกแบบตอบสนองใน React Native)

### Overview (ภาพรวม)

การออกแบบเชิงตอบสนอง (Responsive Design) มีความสำคัญอย่างยิ่งในการพัฒนาแอปพลิเคชันมือถือ เนื่องจากอุปกรณ์มีความหลากหลายในด้านขนาดหน้าจอ การวางแนว (orientation) และความละเอียด (resolution) React Native จึงจัดเตรียมเครื่องมือเพื่อปรับแต่งเลย์เอาต์และคอมโพเนนต์แบบไดนามิกตามมิติของหน้าจอและคุณลักษณะของอุปกรณ์

### Goals of Responsiveness (เป้าหมายของการออกแบบตอบสนอง)

* ทำให้คอมโพเนนต์ UI สามารถปรับขนาดและจัดวางใหม่ได้อย่างเหมาะสมในทุกอุปกรณ์
* หลีกเลี่ยงการกำหนดขนาดตายตัว (fixed dimensions) และเลย์เอาต์แบบ hard-coded
* สนับสนุนการปรับเลย์เอาต์ตามการเปลี่ยนทิศทางหน้าจอ (แนวตั้ง/แนวนอน)

---

### Using `Dimensions.get()` (การใช้ `Dimensions.get()`)

API `Dimensions` ของ React Native ช่วยให้เข้าถึงค่าความกว้างและความสูงของหน้าจอในขณะรันไทม์

```javascript
import { Dimensions } from 'react-native';

const { width, height } = Dimensions.get('window');
```

* เหมาะสำหรับการคำนวณขนาดครั้งเดียว หรือใช้กับเลย์เอาต์ที่มีเงื่อนไข
* คืนค่าขนาดหน้าจอปัจจุบันเป็นข้อมูล snapshot แบบคงที่

---

### Using `useWindowDimensions()` (การใช้ `useWindowDimensions()`)

สำหรับการตอบสนองแบบไดนามิก แนะนำให้ใช้ React hook ที่มีในตัวคือ `useWindowDimensions()`

```javascript
import { useWindowDimensions } from 'react-native';

const { width, height } = useWindowDimensions();
```

* อัปเดตค่าอัตโนมัติเมื่ออุปกรณ์มีการเปลี่ยนการวางแนวหน้าจอ
* เหมาะสำหรับสร้างกริดตอบสนอง (responsive grid) และการเรนเดอร์คอมโพเนนต์ตามเงื่อนไข

---

### Example: Conditional Layout Based on Screen Width (ตัวอย่าง: เลย์เอาต์ตามเงื่อนไขความกว้างหน้าจอ)

```javascript
const { width } = useWindowDimensions();
const isLargeScreen = width > 600;

return (
  <View style={isLargeScreen ? styles.rowLayout : styles.columnLayout}>
    <Text>Item 1</Text>
    <Text>Item 2</Text>
  </View>
);
```

ในตัวอย่างนี้ เลย์เอาต์จะเปลี่ยนเป็น **row layout** เมื่อความกว้างหน้าจอเกิน 600 พิกเซล และเป็น **column layout** เมื่อไม่ถึง

---

### Best Practices for Responsive Design (แนวปฏิบัติที่ดีสำหรับการออกแบบตอบสนอง)

* ใช้ `flex` และมิติแบบร้อยละ (%-based dimensions)
* ลดการใช้ค่าพิกเซลแบบตายตัวให้น้อยที่สุด
* ใช้ `flexWrap` และ `alignContent` เพื่อจัดการ overflow และเลย์เอาต์แบบกริด
* ใช้ `margin` และ `padding` อย่างสม่ำเสมอในการจัดระยะห่าง
* ใช้การเรนเดอร์ตามเงื่อนไข โดยพิจารณาความกว้างหน้าจอหรือการวางแนว

---

### Example of Responsive Box (ตัวอย่างกล่องตอบสนอง)

```javascript
const styles = StyleSheet.create({
  box: {
    width: '90%',
    padding: 20,
    backgroundColor: '#eee',
    marginVertical: 10,
  },
});
```

โค้ดนี้จะสร้างกล่องที่มีความกว้าง 90% ของหน้าจอ ปรับให้เข้ากับทุกอุปกรณ์ โดยยังคงเว้นระยะและสีพื้นหลังที่สม่ำเสมอ


## Platform-Specific Styling in React Native (การจัดรูปแบบที่เฉพาะแพลตฟอร์มใน React Native)

### Overview (ภาพรวม)

React Native สนับสนุนการพัฒนาแบบข้ามแพลตฟอร์มจากชุดโค้ดเดียว แต่ในความเป็นจริง **องค์ประกอบด้านการออกแบบ พฤติกรรม และข้อกำหนดตามระบบปฏิบัติการ** มีความแตกต่างกันระหว่าง iOS และ Android เพื่อสร้างประสบการณ์ผู้ใช้ที่เป็นธรรมชาติ (native look and feel) จึงมักจำเป็นต้องมีการจัดรูปแบบ (styling) ที่เฉพาะแพลตฟอร์ม

React Native มีเครื่องมือที่ช่วยเลือกใช้สไตล์ให้เหมาะกับแพลตฟอร์มที่รันอยู่ ได้แก่:

* `Platform.OS` – คืนค่าชื่อแพลตฟอร์มปัจจุบันเป็น string
* `Platform.select()` – ช่วยสร้างอ็อบเจกต์แบบมีเงื่อนไขสำหรับแต่ละแพลตฟอร์ม

---

### Using `Platform.OS` (การใช้ `Platform.OS`)

```javascript
import { Platform } from 'react-native';

if (Platform.OS === 'ios') {
  // Apply iOS-specific logic
} else {
  // Android-specific logic
}
```

`Platform.OS` จะตรวจสอบว่ากำลังรันบน iOS หรือ Android เพื่อกำหนดตรรกะหรือการตั้งค่าเฉพาะ

---

### Using `Platform.select()` (การใช้ `Platform.select()`)

`Platform.select()` ช่วยให้สามารถคืนค่าอ็อบเจกต์หรือตัวแปรที่แตกต่างกันตามแพลตฟอร์มได้โดยตรง

```javascript
const styles = StyleSheet.create({
  text: {
    fontSize: Platform.select({
      ios: 18,
      android: 16,
    }),
    padding: Platform.select({
      ios: 12,
      android: 8,
    }),
  },
});
```

* เพิ่มความอ่านง่ายของโค้ด
* เหมาะสำหรับการ override สไตล์ เช่น spacing และขนาดฟอนต์ให้สอดคล้องกับ **guideline ของแต่ละระบบ**

---

### Common Use Cases (กรณีการใช้งานที่พบบ่อย)

* การกำหนดขนาดตัวอักษร (font size) และระยะบรรทัด (line height)
* การปรับระยะห่าง (padding และ spacing)
* การเรนเดอร์คอมโพเนนต์ตามเงื่อนไข (เช่น ใช้ `ActionSheetIOS` ใน iOS แต่ใช้ dialog ของ Android)
* การ import คอมโพเนนต์เฉพาะระบบ

---

### Example: Platform-Aware Button (ตัวอย่าง: ปุ่มที่ขึ้นอยู่กับแพลตฟอร์ม)

```javascript
const buttonStyle = {
  backgroundColor: Platform.OS === 'ios' ? '#007AFF' : '#2196F3',
  padding: 10,
  borderRadius: 5,
};
```

* ถ้าเป็น iOS จะใช้สีน้ำเงินโทน `#007AFF` (ใกล้เคียงกับปุ่ม native ของ iOS)
* ถ้าเป็น Android จะใช้สีน้ำเงิน `#2196F3` (ใกล้เคียงกับ Material Design)

---

### Best Practices (แนวปฏิบัติที่ดี)

* รวมตรรกะแพลตฟอร์มไว้ใน **style หรือ helper function เดียว** เพื่อลดความซ้ำซ้อน
* รักษาประสบการณ์ผู้ใช้ (UX) ให้สอดคล้องกันข้ามแพลตฟอร์ม ขณะเดียวกันก็เคารพแนวทางการออกแบบของแต่ละระบบ
* ลดการแตกต่างของโค้ดให้น้อยที่สุด เว้นแต่จำเป็นต่อการทำงานหรือการปฏิบัติตามข้อกำหนดด้านการออกแบบ



---

## Safe Area Management in React Native (การจัดการพื้นที่ปลอดภัยใน React Native)

### Overview (ภาพรวม)

อุปกรณ์พกพารุ่นใหม่ (โดยเฉพาะ iOS ที่มี notch, home indicator หรือขอบโค้งมน) จำเป็นต้องออกแบบเลย์เอาต์ให้เคารพพื้นที่ที่เรียกว่า **safe area** เพื่อหลีกเลี่ยงการซ้อนทับกับองค์ประกอบของระบบ เช่น แถบสถานะ (status bar), navigation bar หรือ gesture indicator

React Native จึงมีคอมโพเนนต์ **`SafeAreaView`** เพื่อช่วยจัดการปัญหานี้

---

### What is a Safe Area? (Safe Area คืออะไร?)

**Safe Area** คือพื้นที่ของหน้าจอที่รับประกันว่าคอนเทนต์จะแสดงผลอย่างชัดเจน โดยไม่ถูกบังด้วยองค์ประกอบของระบบ เช่น:

* รอยบาก (notches) หรือ cutouts (เช่น iPhone X ขึ้นไป)
* แถบสถานะ (status bar) และแถบนำทาง (navigation bar)
* พื้นที่ gesture หรือ home indicator

---

### Using `SafeAreaView` (การใช้งาน `SafeAreaView`)

```javascript
import { SafeAreaView, Text } from 'react-native';

export default function App() {
  return (
    <SafeAreaView style={{ flex: 1 }}>
      <Text>Content inside safe area</Text>
    </SafeAreaView>
  );
}
```

* `SafeAreaView` จะทำให้คอนเทนต์ภายในถูกแสดงในขอบเขตที่ปลอดภัย
* ค่าเริ่มต้นจะมีผลเฉพาะบน **iOS** (บน Android มักไม่มีผลมากนัก แต่ควรใช้เพื่อความสม่ำเสมอ)

---

### Best Practices (แนวปฏิบัติที่ดี)

* ใช้ `SafeAreaView` ที่ root ของแต่ละหน้าจอ เพื่อป้องกันคอนเทนต์ถูกตัด
* ผสมผสานการใช้ `padding` และ `flex` เพื่อจัดระยะห่างอย่างเหมาะสม
* สำหรับงานที่ซับซ้อน แนะนำให้ใช้ไลบรารี **`react-native-safe-area-context`** ซึ่งรองรับทั้ง iOS และ Android พร้อม API แบบ hooks

---

### Example: Safe Header Layout (ตัวอย่างเลย์เอาต์หัวข้อที่ปลอดภัย)

```javascript
<SafeAreaView style={{ flex: 1, backgroundColor: '#fff' }}>
  <View style={{ padding: 16 }}>
    <Text style={{ fontSize: 20 }}>Welcome</Text>
  </View>
</SafeAreaView>
```

ในตัวอย่างนี้ `SafeAreaView` ช่วยให้หัวข้อ "Welcome" แสดงในตำแหน่งที่ปลอดภัย ไม่ถูกทับกับ notch หรือ status bar

---

### Safe Area on Android (Safe Area บน Android)

โดยทั่วไป อุปกรณ์ Android ไม่จำเป็นต้องจัดการ safe area เป็นพิเศษ อย่างไรก็ตาม ควรใช้ `SafeAreaView` เพื่อความสอดคล้อง โดยเฉพาะเมื่อทำงานกับเลย์เอาต์แบบ immersive หรือ edge-to-edge


---

## ตัวอย่างเชิงปฏิบัติ: การออกแบบเลย์เอาต์แบบสองคอลัมน์ที่ตอบสนอง (Two-Column Responsive Layout)

### ภาพรวม (Overview)

การออกแบบเลย์เอาต์ที่ตอบสนอง (Responsive Layout) มักต้องมีการปรับจำนวนและการจัดเรียงคอลัมน์ให้เหมาะสมกับความกว้างของหน้าจอแบบไดนามิก ในส่วนนี้ เราจะสร้างเลย์เอาต์สองคอลัมน์พื้นฐานโดยใช้ **Flexbox** ซึ่งสามารถปรับให้เข้ากับขนาดและการหมุนของหน้าจอที่แตกต่างกันได้

---

### วัตถุประสงค์ของเลย์เอาต์ (Layout Objective)

การออกแบบเลย์เอาต์นี้ตั้งเป้าให้:

* มีสองคอลัมน์ที่แสดงแบบ **เคียงข้างกัน** เมื่ออยู่บนหน้าจอขนาดใหญ่
* คอลัมน์จะ **ซ้อนในแนวตั้ง** เมื่ออยู่บนหน้าจอแคบ (เช่น โทรศัพท์ในแนวตั้ง)
* แต่ละคอลัมน์มีความกว้างเท่ากันและคงระยะห่างที่สม่ำเสมอ

---

### การนำไปใช้ (Implementation)

```javascript
import React from 'react';
import { View, Text, StyleSheet } from 'react-native';

export default function ResponsiveLayout() {
  return (
    <View style={styles.container}>
      <View style={styles.column}><Text>Column 1</Text></View>
      <View style={styles.column}><Text>Column 2</Text></View>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    padding: 10,
  },
  column: {
    flex: 1,
    minWidth: '45%',
    margin: 10,
    padding: 20,
    backgroundColor: '#eee',
  },
});
```

---

### คำอธิบาย (Explanation)

* `flexDirection: 'row'` – จัดคอลัมน์ให้อยู่ข้างกันในแนวนอนเมื่อหน้าจอกว้าง
* `flexWrap: 'wrap'` – อนุญาตให้คอลัมน์เลื่อนไปบรรทัดถัดไปหากพื้นที่ไม่พอ
* `flex: 1` – ให้แต่ละคอลัมน์มีความกว้างเท่ากันในพื้นที่ที่เหลือ
* `minWidth: '45%'` – ป้องกันไม่ให้คอลัมน์หดจนอ่านไม่ออก
* `margin` และ `padding` – กำหนดระยะห่างรอบและภายในคอลัมน์
* `backgroundColor: '#eee'` – เพิ่มสีพื้นหลังเพื่อให้มองเห็นคอลัมน์ได้ชัดเจน

---

### พฤติกรรมบนหน้าจอต่าง ๆ (Behavior on Different Screens)

* **แท็บเล็ตหรือโหมดแนวนอน:** คอลัมน์จะจัดเรียงเคียงข้างกัน
* **โทรศัพท์ในโหมดแนวตั้ง:** คอลัมน์จะถูกจัดเรียงซ้อนกันในแนวตั้ง

---

### การปรับปรุงเพิ่มเติม (Enhancements)

เลย์เอาต์นี้สามารถขยายเพิ่มเติมได้ เช่น:

* รองรับมากกว่า 2 คอลัมน์โดยใช้รูปแบบเดียวกัน
* ใช้ `useWindowDimensions()` เพื่อตรวจจับความกว้างหน้าจอแล้วปรับการแสดงผลแบบไดนามิก
* สร้างคอมโพเนนต์ `Column` ที่นำกลับมาใช้ใหม่ได้ โดยส่งค่า props

---

### บทสรุป (Conclusion)

รูปแบบเลย์เอาต์สองคอลัมน์ที่ตอบสนอง (Responsive Two-Column Layout) นี้แสดงให้เห็นว่า เราสามารถใช้ **Flexbox** และหลักการออกแบบที่ตอบสนอง เพื่อสร้างอินเทอร์เฟซที่สะอาด ยืดหยุ่น และสามารถปรับให้เข้ากับอุปกรณ์และการวางหน้าจอที่หลากหลายได้

