
# สัปดาห์ที่ 2 ของเดือนกันยายน 2025

**หัวข้อ: การจัดเก็บข้อมูลภายใน (Internal Storage)**

---

## บทนำ (Introduction)

### ภาพรวมของการพัฒนาแอปพลิเคชันบนอุปกรณ์เคลื่อนที่

ในภูมิทัศน์ของซอฟต์แวร์ร่วมสมัย แอปพลิเคชันบนอุปกรณ์เคลื่อนที่มีบทบาทสำคัญในการเพิ่มประสิทธิภาพการทำงาน อำนวยความสะดวกในการสื่อสาร และทำให้สามารถเข้าถึงข้อมูลได้ทุกที่ทุกเวลา ตัวอย่างพื้นฐานที่สะท้อนให้เห็นถึงการเพิ่มประสิทธิภาพการทำงานได้อย่างชัดเจนคือ **แอปพลิเคชันรายการสิ่งที่ต้องทำ (To-do List App)** ซึ่งครอบคลุมคุณลักษณะสำคัญ เช่น การโต้ตอบกับผู้ใช้ การจัดการสถานะ และการจัดเก็บข้อมูลถาวร แอปพลิเคชันประเภทนี้จึงเหมาะสมที่จะใช้เป็นกรณีศึกษาเบื้องต้นในการทำความเข้าใจแนวคิดหลักในการพัฒนาแอปพลิเคชันบนอุปกรณ์เคลื่อนที่ด้วยเฟรมเวิร์กสมัยใหม่

### บทนำสู่ React Native

**React Native** เป็นเฟรมเวิร์กแบบโอเพนซอร์สที่พัฒนาโดย Facebook ซึ่งช่วยให้นักพัฒนาสามารถสร้างแอปพลิเคชันบนอุปกรณ์เคลื่อนที่โดยใช้ **JavaScript** และ **React** แตกต่างจากการพัฒนาแบบเนทีฟดั้งเดิมที่ต้องใช้ codebase แยกกันสำหรับ Android และ iOS React Native มอบ codebase เดียวที่ยังคงสามารถเรนเดอร์องค์ประกอบแบบเนทีฟได้ ทำให้เกิดทั้งประสิทธิภาพและความคล่องตัว

คุณลักษณะเด่นของ React Native ได้แก่:

* ความสามารถในการทำงานข้ามแพลตฟอร์ม (iOS และ Android)
* รูปแบบ UI แบบ Declarative
* สถาปัตยกรรมเชิงองค์ประกอบ (Component-based architecture)
* การเชื่อมต่อกับ API ของระบบผ่าน bridges

### วัตถุประสงค์ของโมดูล

วัตถุประสงค์หลักของโมดูลนี้คือการแนะนำผู้เรียนให้เข้าใจ **การพัฒนาแอปพลิเคชัน To-do List แบบครบวงจร** โดยใช้ React Native โดยมุ่งเน้นเป้าหมายทางการเรียนการสอนดังนี้:

* การแนะนำ **การจัดเก็บข้อมูลถาวรในเครื่อง** ผ่าน `AsyncStorage` ซึ่งเป็นระบบจัดเก็บข้อมูลแบบคีย์–ค่า (key–value) ที่ไม่เข้ารหัส ทำงานแบบอะซิงโครนัส

* การประยุกต์ใช้ **การดำเนินการ CRUD** ได้แก่:

  * **Create** – เพิ่มงานใหม่
  * **Read** – ดึงข้อมูลงานที่บันทึกไว้เมื่อเปิดแอป
  * **Update** – แก้ไขงานที่มีอยู่
  * **Delete** – ลบงานที่ไม่ต้องการ

* การเสริมสร้างความเข้าใจในแนวคิดการเขียนโปรแกรมหลัก เช่น:

  * การจัดการสถานะด้วย `useState`
  * การควบคุมวงจรชีวิตด้วย `useEffect`
  * การทำ Serialization ข้อมูลด้วย JSON
  * การเรนเดอร์รายการอย่างมีประสิทธิภาพด้วย `FlatList`

### ทำไมต้องเป็นแอป To-do List?

แอป To-do List เหมาะสมสำหรับการใช้เป็นกรณีศึกษาเชิงการสอน เนื่องจากความเรียบง่ายและความสามารถในการสาธิตฟังก์ชันหลักของแอปพลิเคชันบนอุปกรณ์เคลื่อนที่ ได้แก่:

* **การจัดการข้อมูลนำเข้าของผู้ใช้**: การดักจับและตรวจสอบความถูกต้องของข้อมูลจาก `TextInput`
* **การโต้ตอบที่มีสถานะ (Stateful Interaction)**: การสังเกตการเปลี่ยนแปลงสถานะแบบเรียลไทม์และผลลัพธ์ที่สะท้อนใน UI
* **การจัดเก็บข้อมูลถาวร**: การทำความเข้าใจการจัดเก็บข้อมูลผู้ใช้ข้าม session ผ่าน local storage
* **การออกแบบแบบโมดูลและการขยายได้**: เป็นรากฐานสำหรับการเพิ่มคุณลักษณะใหม่ เช่น วันครบกำหนด ลำดับความสำคัญ และการแจ้งเตือน

### ผลลัพธ์การเรียนรู้

เมื่อเรียนจบโมดูลนี้ ผู้เรียนจะสามารถ:

1. พัฒนาแอปพลิเคชันข้ามแพลตฟอร์มโดยใช้ React Native
2. จัดการสถานะแบบไดนามิกและจัดการข้อมูลนำเข้าจากผู้ใช้
3. ใช้การจัดเก็บข้อมูลถาวรด้วย `AsyncStorage`
4. ประยุกต์ใช้การดำเนินการ CRUD ภายในบริบทของแอปพลิเคชันมือถือ
5. ออกแบบและตกแต่งส่วนติดต่อผู้ใช้ตามแนวทางปฏิบัติที่ดีในการพัฒนาแอปบนอุปกรณ์เคลื่อนที่


---

## โครงสร้างข้อมูลที่ใช้ในแอปพลิเคชัน (Data Structures Used in the Application)

ในการออกแบบแอปพลิเคชันบนอุปกรณ์เคลื่อนที่ เช่น แอป To-do List การเลือกและการนำโครงสร้างข้อมูลที่เหมาะสมมาใช้งานถือว่ามีบทบาทสำคัญอย่างยิ่งในการสร้างสมดุลระหว่างประสิทธิภาพ (performance) ความสามารถในการบำรุงรักษา (maintainability) และความถูกต้องของระบบ (correctness) ส่วนนี้จะอธิบายโครงสร้างข้อมูลหลักที่ใช้ในแอปพลิเคชัน React Native To-do List

---

### อาเรย์ (Array)

อาเรย์เป็นโครงสร้างข้อมูลพื้นฐานที่ใช้จัดเก็บรายการของสิ่งที่ต้องทำ (to-do items) โดยอาเรย์เป็นกลไกที่สะดวกและมีประสิทธิภาพสำหรับการจัดเก็บข้อมูลที่มีลำดับ (ordered collections) ซึ่งเหมาะสมกับการเรนเดอร์ UI ที่อยู่ในรูปแบบรายการ

* ใน React Native อาเรย์มักถูกเก็บไว้ใน state ของคอมโพเนนต์ผ่าน hook `useState`:

```javascript
const [todos, setTodos] = useState([]);
```

* แต่ละรายการในอาเรย์แทนงานหนึ่งชิ้นใน To-do List
* อาเรย์ถูกเรนเดอร์ไปยัง UI โดยใช้คอมโพเนนต์ที่เหมาะสมกับการทำงานกับข้อมูลจำนวนมาก เช่น `FlatList`
* การเพิ่ม ลบ หรือแก้ไขงาน จะทำผ่านการปรับเปลี่ยนค่าในอาเรย์นี้

---

### ออบเจ็กต์ (Object: To-do Item Representation)

แต่ละรายการของ To-do List ถูกแทนค่าเป็นออบเจ็กต์ในภาษา JavaScript แนวทางนี้ช่วยให้คุณลักษณะที่เกี่ยวข้องกันหลาย ๆ อย่างสามารถจัดกลุ่มไว้ด้วยกันได้ ทำให้โค้ดอ่านง่ายและจัดการได้สะดวก

* ตัวอย่างโครงสร้างออบเจ็กต์ของรายการสิ่งที่ต้องทำ:

```javascript
{
    id: 1690909090909,
    title: "Buy groceries"
}
```

* ฟิลด์ `id` ใช้เป็นตัวระบุที่ไม่ซ้ำกัน (unique identifier) โดยมักจะสร้างด้วย `Date.now()` เพื่อให้สามารถเข้าถึงหรือลบงานนั้น ๆ ได้อย่างถูกต้อง
* ฟิลด์ `title` เก็บข้อความของงานที่ผู้ใช้ป้อน
* ในเวอร์ชันที่พัฒนาต่อไป อาจเพิ่มฟิลด์อื่น ๆ เช่น `completed`, `dueDate`, หรือ `priority` เพื่อรองรับฟังก์ชันเพิ่มเติม

---

### คู่คีย์–ค่า (Key–Value Pairs: AsyncStorage Mechanism)

`AsyncStorage` เป็นระบบจัดเก็บข้อมูลแบบคีย์–ค่า ที่ทำงานแบบอะซิงโครนัสและไม่เข้ารหัส ใช้สำหรับเก็บข้อมูลถาวรภายในอุปกรณ์ของผู้ใช้

* ในที่นี้ คีย์มักจะเป็นสตริงที่ไม่ซ้ำ เช่น `"todos"` และค่าจะเป็นอาเรย์ของออบเจ็กต์รายการงานที่ถูกทำการ serialize
* ตัวอย่างการใช้งาน:

```javascript
await AsyncStorage.setItem("todos", jsonString);
const data = await AsyncStorage.getItem("todos");
```

* โครงสร้างนี้ทำให้มั่นใจได้ว่าข้อมูลของผู้ใช้จะยังคงอยู่แม้ว่าแอปจะถูกปิดและเปิดใหม่

---

### JSON (JavaScript Object Notation)

เนื่องจาก `AsyncStorage` รองรับการเก็บข้อมูลในรูปแบบ string เท่านั้น โครงสร้างข้อมูลที่ซับซ้อน เช่น อาเรย์หรือออบเจ็กต์ จำเป็นต้องถูกแปลง (serialize) ไปเป็นสตริงก่อนด้วย JSON

* การบันทึกข้อมูล:

```javascript
const jsonString = JSON.stringify(todos);
```

* การเรียกคืนข้อมูล:

```javascript
const todos = JSON.parse(jsonString);
```

* JSON จึงทำหน้าที่เป็นสะพานเชื่อมระหว่างโครงสร้างข้อมูลของ JavaScript และรูปแบบสตริงที่ AsyncStorage ต้องการ
* กระบวนการนี้ช่วยคงความสมบูรณ์และความถูกต้องของข้อมูลเมื่อจัดเก็บและเรียกคืน

---

### สรุป (Summary)

โดยสรุป แอปพลิเคชัน To-do List ใช้การผสมผสานของ **อาเรย์ ออบเจ็กต์ การจัดเก็บแบบคีย์–ค่า และ JSON Serialization** เพื่อจัดการและคงข้อมูลของผู้ใช้ โครงสร้างเหล่านี้ทำงานร่วมกันอย่างเป็นระบบ ช่วยให้โค้ดมีประสิทธิภาพ อ่านง่าย และบำรุงรักษาได้สะดวก ซึ่งถือเป็นแกนกลางของตรรกะหลักในแอปพลิเคชัน


---

## การดำเนินการ CRUD บนที่เก็บข้อมูล (CRUD Operations on Storage)

ในการพัฒนาแอปพลิเคชัน โดยเฉพาะระบบที่เน้นผู้ใช้ (user-centered systems) ความสามารถในการดำเนินการ **CRUD** ได้แก่ **Create, Read, Update, Delete** ถือเป็นพื้นฐานสำคัญของการจัดการข้อมูล ภายในแอป To-do List การดำเนินการ CRUD ถูกนำมาใช้โดยอาศัยทั้งโครงสร้างข้อมูลใน JavaScript และกลไกการจัดเก็บข้อมูลถาวรของ React Native ที่เรียกว่า `AsyncStorage`

ส่วนนี้จะอธิบายรายละเอียดของแต่ละการดำเนินการ พร้อมตัวอย่างโค้ดที่ใช้จริงใน React Native

---

### Create: การเพิ่มงานใหม่ (Adding a New To-do Item)

การดำเนินการ “Create” ช่วยให้ผู้ใช้สามารถเพิ่มงานใหม่เข้าไปใน To-do List ได้ โดยกระบวนการนี้เกี่ยวข้องกับการรับค่าที่ผู้ใช้ป้อน สร้างออบเจ็กต์ใหม่ อัปเดตอาเรย์ใน state และบันทึกอาเรย์ที่อัปเดตแล้วลงใน `AsyncStorage`

**กลไก (Mechanism):**

* ผู้ใช้ป้อนข้อความผ่านคอมโพเนนต์ `TextInput`
* สร้างออบเจ็กต์งานใหม่ที่มี `id` ไม่ซ้ำ โดยใช้ `Date.now()`
* เพิ่มออบเจ็กต์ใหม่เข้าไปในอาเรย์ `todos`
* บันทึกอาเรย์ที่อัปเดตแล้วลงใน `AsyncStorage`

**ตัวอย่างโค้ด:**

```javascript
const addTodo = async () => {
  const newTodo = {
    id: Date.now(),
    title: inputText,
  };
  const updatedTodos = [...todos, newTodo];
  setTodos(updatedTodos);
  await AsyncStorage.setItem('todos', JSON.stringify(updatedTodos));
  setInputText('');
};
```

---

### Read: การโหลดข้อมูลจากที่เก็บ (Loading Data from Storage)

การดำเนินการ “Read” ทำหน้าที่ดึงรายการงานที่บันทึกไว้จาก `AsyncStorage` เมื่อแอปพลิเคชันเริ่มทำงานหรือถูกรีเฟรช เพื่อให้มั่นใจว่าข้อมูลของผู้ใช้ยังคงอยู่ระหว่างการใช้งานหลายครั้ง

**กลไก (Mechanism):**

* เมื่อคอมโพเนนต์เริ่มทำงานครั้งแรก ใช้ `useEffect` เพื่อเรียกอ่านข้อมูลแบบอะซิงโครนัส
* ข้อมูลที่อ่านได้จาก `AsyncStorage` ถูกแปลงกลับเป็นโครงสร้างด้วย `JSON.parse()`
* กำหนดค่าอาเรย์ `todos` ให้ตรงกับข้อมูลที่ได้

**ตัวอย่างโค้ด:**

```javascript
useEffect(() => {
  const loadTodos = async () => {
    const data = await AsyncStorage.getItem('todos');
    if (data) {
      setTodos(JSON.parse(data));
    }
  };
  loadTodos();
}, []);
```

---

### Update: การแก้ไขงานที่มีอยู่ (Editing an Existing To-do)

การดำเนินการ “Update” ช่วยให้ผู้ใช้สามารถแก้ไขเนื้อหาของงานที่มีอยู่ได้ โดยทั่วไปจะเกี่ยวข้องกับการเลือกงานเพื่อแก้ไข ปรับค่าของมัน และบันทึกอาเรย์ใหม่กลับไปยังที่เก็บถาวร

**กลไก (Mechanism):**

* โหลดงานที่ต้องการแก้ไขเข้าสู่ฟิลด์ `TextInput`
* หลังจากแก้ไขแล้ว อัปเดตรายการที่ตรงกับ `id` ในอาเรย์ `todos`
* บันทึกอาเรย์ที่แก้ไขแล้วกลับไปยัง `AsyncStorage`

**ตัวอย่างโค้ด:**

```javascript
const updateTodo = async () => {
  const updatedTodos = todos.map(todo => 
    todo.id === editingId ? { ...todo, title: inputText } : todo
  );
  setTodos(updatedTodos);
  await AsyncStorage.setItem('todos', JSON.stringify(updatedTodos));
  setEditingId(null);
  setInputText('');
};
```

---

### Delete: การลบงาน (Removing a To-do Item)

การดำเนินการ “Delete” อนุญาตให้ผู้ใช้ลบงานออกจากรายการได้ โดยการกรองอาเรย์เพื่อเอางานที่มี `id` ตรงกับงานเป้าหมายออก และอัปเดตทั้ง state และข้อมูลที่จัดเก็บ

**กลไก (Mechanism):**

* ระบุงานที่ต้องการลบโดยใช้ `id`
* กรองอาเรย์เพื่อเอางานนั้นออก
* บันทึกอาเรย์ที่อัปเดตแล้วลงใน state และ `AsyncStorage`

**ตัวอย่างโค้ด:**

```javascript
const deleteTodo = async (id) => {
  const filteredTodos = todos.filter(todo => todo.id !== id);
  setTodos(filteredTodos);
  await AsyncStorage.setItem('todos', JSON.stringify(filteredTodos));
};
```

---

### สรุป (Summary)

การดำเนินการ CRUD ที่ถูกนำมาใช้ในแอปพลิเคชัน To-do List แสดงให้เห็นถึงเทคนิคสำคัญของการจัดการ state ใน React Native ที่ทำงานร่วมกับการเก็บข้อมูลถาวรผ่าน `AsyncStorage` กระบวนการเหล่านี้ทำให้วงจรการจัดการข้อมูลครบถ้วน (การสร้าง การอ่าน การแก้ไข และการลบ) ซึ่งช่วยให้ผู้เรียนได้รับประสบการณ์เชิงปฏิบัติอย่างรอบด้านในการพัฒนาแอปพลิเคชันบนอุปกรณ์เคลื่อนที่


---

## การสร้างโปรเจกต์ (Creating the Project)

ส่วนนี้อธิบายขั้นตอนการเริ่มต้นสร้างโปรเจกต์ใหม่ด้วย React Native โดยใช้ **Expo CLI** ซึ่งช่วยลดความซับซ้อนของการตั้งค่าและกระบวนการพัฒนา โดยเฉพาะอย่างยิ่งสำหรับผู้เริ่มต้น เนื่องจาก Expo มีเครื่องมือที่จัดเตรียมมาให้ครบถ้วนสำหรับการสร้างและทดสอบแอปพลิเคชัน React Native

---

### การติดตั้ง Expo CLI (Installing Expo CLI)

ก่อนที่จะสร้างโปรเจกต์ใหม่ นักพัฒนาจำเป็นต้องติดตั้ง Expo CLI ลงในเครื่องก่อน โดยติดตั้งแบบ global ผ่าน Node Package Manager (npm) ดังนี้:

```bash
npm install -g expo-cli
```

---

### การสร้างโปรเจกต์ใหม่ (Creating a New Project)

เมื่อทำการติดตั้ง CLI เรียบร้อยแล้ว สามารถสร้างโปรเจกต์ใหม่ได้ด้วยคำสั่ง:

```bash
expo init TodoApp
```

เมื่อระบบถามให้เลือก template ให้เลือก **blank (JavaScript)** ซึ่งจะสร้างโครงสร้างโปรเจกต์พื้นฐานที่เหมาะสำหรับการพัฒนาและการทำ prototype อย่างรวดเร็ว

---

### การติดตั้ง AsyncStorage (Installing AsyncStorage)

เพื่อให้แอปพลิเคชันสามารถจัดเก็บข้อมูลถาวรได้ จำเป็นต้องติดตั้งโมดูล `@react-native-async-storage/async-storage` ไลบรารีนี้เป็นระบบ key–value storage แบบอะซิงโครนัสที่ไม่มีการเข้ารหัส ซึ่งสามารถทำงานได้ทั้งบน Android และ iOS

```bash
npx expo install @react-native-async-storage/async-storage
```

---

### การรันแอปพลิเคชัน (Running the Application)

นักพัฒนาสามารถเริ่มรันแอปได้ด้วยคำสั่งใดคำสั่งหนึ่งดังต่อไปนี้:

```bash
npm start
```

หรือ

```bash
expo start
```

คำสั่งนี้จะเปิด **Metro Bundler** บนเบราว์เซอร์ ทำให้นักพัฒนาสามารถเลือกได้ว่าจะรันแอปบน **emulator**, **อุปกรณ์จริง** หรือ **web simulator**

---

## ส่วนติดต่อผู้ใช้ (User Interface: UI) และการจัดรูปแบบ (Styling)

การออกแบบส่วนติดต่อผู้ใช้ที่ดีมีความสำคัญต่อ **การใช้งาน (usability)** และ **การมีส่วนร่วมของผู้ใช้ (user engagement)** ใน React Native มีการจัดเตรียม **คอมโพเนนต์หลัก (core UI components)** และระบบจัดรูปแบบ (styling system) ที่มีความยืดหยุ่นเพื่อสร้างเลย์เอาต์ที่ตอบสนอง (responsive) และสวยงาม

---

### คอมโพเนนต์หลักของ UI (Core UI Components)

แอปพลิเคชัน **To-do List** ใช้คอมโพเนนต์หลักของ React Native ดังต่อไปนี้:

* `View` – ใช้เป็นคอนเทนเนอร์ (container) สำหรับจัดโครงสร้างเลย์เอาต์
* `Text` – ใช้สำหรับแสดงข้อความแบบคงที่หรือข้อความที่เปลี่ยนแปลงได้
* `TextInput` – ฟิลด์สำหรับให้ผู้ใช้กรอกข้อมูล
* `TouchableOpacity` – องค์ประกอบที่กดได้ ทำงานเสมือนปุ่ม
* `FlatList` – ใช้สำหรับแสดงรายการแบบไดนามิกที่มีประสิทธิภาพสูง

---

### ตัวอย่างโครงสร้าง UI (Example UI Structure)

```javascript
<View style={styles.container}>
  <Text style={styles.heading}>To-do List</Text>
  <TextInput
    value={inputText}
    onChangeText={setInputText}
    style={styles.input}
    placeholder="Enter a task"
  />
  <TouchableOpacity onPress={addTodo} style={styles.button}>
    <Text style={styles.buttonText}>Add</Text>
  </TouchableOpacity>
  <FlatList
    data={todos}
    keyExtractor={item => item.id.toString()}
    renderItem={({ item }) => (
      <View style={styles.todoItem}>
        <Text>{item.title}</Text>
      </View>
    )}
  />
</View>
```

---

### การอธิบาย (Explanation)

* `View` ทำหน้าที่เป็นโครงสร้างหลักสำหรับจัดกลุ่มคอมโพเนนต์ย่อย
* `Text` ใช้เป็นหัวข้อ เช่น **To-do List**
* `TextInput` ทำหน้าที่รับข้อความจากผู้ใช้ ซึ่งจะถูกบันทึกเป็นงานใหม่
* `TouchableOpacity` ทำหน้าที่เป็นปุ่ม เพิ่มงานใหม่เข้าสู่รายการ
* `FlatList` แสดงรายการงานทั้งหมดที่ผู้ใช้ได้เพิ่มไว้ โดยรองรับประสิทธิภาพสูงแม้ในกรณีที่มีข้อมูลจำนวนมาก

---

## ซอร์สโค้ดสมบูรณ์ของแอปพลิเคชัน (Complete Application Source Code)

ด้านล่างนี้เป็นซอร์สโค้ดสมบูรณ์ของแอปพลิเคชัน **To-do List** โดยในโค้ดมีการจัดการการเพิ่มงาน (Add), การแก้ไข (Edit), การอัปเดต (Update), และการลบงาน (Delete) พร้อมกับการจัดเก็บข้อมูลถาวรโดยใช้ `AsyncStorage`

```javascript
import React, { useState, useEffect } from 'react';
import { View, Text, TextInput, TouchableOpacity, FlatList, StyleSheet, Alert } from 'react-native';
import AsyncStorage from '@react-native-async-storage/async-storage';

export default function App() {
  const [todos, setTodos] = useState([]);
  const [text, setText] = useState('');
  const [editingIndex, setEditingIndex] = useState(null);

  useEffect(() => {
    loadTodos();
  }, []);

  const loadTodos = async () => {
    try {
      const data = await AsyncStorage.getItem('@todos');
      if (data !== null) {
        setTodos(JSON.parse(data));
      }
    } catch (e) {
      console.error('Failed to load todos.');
    }
  };

  const saveTodos = async (newTodos) => {
    try {
      await AsyncStorage.setItem('@todos', JSON.stringify(newTodos));
    } catch (e) {
      console.error('Failed to save todos.');
    }
  };

  const handleAdd = () => {
    if (text.trim() === '') {
      Alert.alert('Please enter a task before adding.');
      return;
    }
    const newItem = { id: Date.now().toString(), title: text };
    const updated = [...todos, newItem];
    setTodos(updated);
    saveTodos(updated);
    setText('');
  };

  const handleEdit = (item, index) => {
    setText(item.title);
    setEditingIndex(index);
  };

  const handleUpdate = () => {
    const updated = [...todos];
    updated[editingIndex].title = text;
    setTodos(updated);
    saveTodos(updated);
    setEditingIndex(null);
    setText('');
  };

  const handleDelete = (id) => {
    const updated = todos.filter(item => item.id !== id);
    setTodos(updated);
    saveTodos(updated);
  };

  return (
    <View style={styles.container}>
      <Text style={styles.title}>TO-DO LIST</Text>

      <TextInput
        style={styles.input}
        value={text}
        onChangeText={setText}
        placeholder="Add a new task..."
      />

      {editingIndex !== null ? (
        <TouchableOpacity style={styles.button} onPress={handleUpdate}>
          <Text style={styles.buttonText}>Update</Text>
        </TouchableOpacity>
      ) : (
        <TouchableOpacity style={styles.button} onPress={handleAdd}>
          <Text style={styles.buttonText}>Add</Text>
        </TouchableOpacity>
      )}

      <FlatList
        data={todos}
        keyExtractor={(item) => item.id}
        renderItem={({ item, index }) => (
          <View style={styles.todoItem}>
            <Text>{item.title} </Text>
            <View style={styles.buttons}>
              <TouchableOpacity onPress={() => handleEdit(item, index)}>
                <Text style={styles.edit}>Edit</Text>
              </TouchableOpacity>
              <TouchableOpacity onPress={() => handleDelete(item.id)}>
                <Text style={styles.delete}>Delete</Text>
              </TouchableOpacity>
            </View>
          </View>
        )}
      />
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1, justifyContent: 'center', alignItems: 'center', padding: 20,
  },
  title: {
    fontSize: 24, fontWeight: 'bold', marginBottom: 20,
  },
  input: {
    width: '100%', borderWidth: 1, padding: 10, marginBottom: 10, borderRadius: 5,
  },
  button: {
    backgroundColor: '#28a745', padding: 10, borderRadius: 5, marginBottom: 20,
  },
  buttonText: {
    color: 'white',
  },
  todoItem: {
    width: '100%', padding: 10, borderBottomWidth: 1, borderColor: '#ccc', 
    flexDirection: 'row', justifyContent: 'space-between', alignItems: 'center',
  },
  buttons: {
    flexDirection: 'row', gap: 10,
  },
  edit: {
    color: 'blue', marginRight: 10,
  },
  delete: {
    color: 'red',
  },
});
```

---

### คำอธิบายเชิงวิชาการ

1. **การจัดการสถานะ (State Management):**
   ใช้ `useState` สำหรับเก็บข้อมูลรายการงาน (`todos`), ข้อความอินพุต (`text`), และดัชนีงานที่กำลังแก้ไข (`editingIndex`).

2. **การทำงานกับวงจรชีวิตคอมโพเนนต์ (Lifecycle Management):**
   ใช้ `useEffect` สำหรับโหลดข้อมูล (`loadTodos`) จาก `AsyncStorage` เมื่อแอปถูกเปิดขึ้น

3. **การจัดเก็บข้อมูลถาวร (Persistent Storage):**
   ใช้ `AsyncStorage` ในการบันทึก (`saveTodos`) และดึงข้อมูล (`loadTodos`) เพื่อรักษารายการงานแม้เมื่อปิดแอปแล้ว

4. **การปฏิบัติการ CRUD:**

   * **Create (เพิ่ม):** `handleAdd`
   * **Read (อ่าน):** `loadTodos`
   * **Update (แก้ไข):** `handleUpdate`
   * **Delete (ลบ):** `handleDelete`

5. **การออกแบบ UI:**
   ใช้ `View`, `Text`, `TextInput`, `TouchableOpacity`, และ `FlatList` เพื่อสร้างโครงสร้างที่ใช้งานง่ายและตอบสนองต่อผู้ใช้

