
# **บทที่ 2 การเขียนโปรแกรม React Native เบื้องต้น**


## **2.1. บทนำ**

การพัฒนาแอปพลิเคชันในยุคดิจิทัลปัจจุบันกำลังเปลี่ยนผ่านจากแนวทางการเขียนโปรแกรมแบบดั้งเดิม ไปสู่แนวทางที่ให้ความสำคัญกับ “สถาปัตยกรรมซอฟต์แวร์เชิงองค์ประกอบ” (Component-based Software Architecture) และ “การเขียนโปรแกรมเชิงประกาศ” (Declarative Programming) ซึ่งเน้นการอธิบายผลลัพธ์ของระบบ มากกว่าการระบุขั้นตอนการทำงานอย่างละเอียด React Native เป็นหนึ่งในแพลตฟอร์มที่สะท้อนแนวคิดเหล่านี้ได้อย่างชัดเจน โดยนำหลักการของ React มาประยุกต์ใช้ในบริบทของอุปกรณ์พกพา เพื่อสร้างส่วนติดต่อผู้ใช้ (User Interface) ที่ตอบสนองต่อการเปลี่ยนแปลงของข้อมูลได้แบบพลวัต (Dynamic UI Behavior)

ในเชิงทฤษฎี React Native เป็นตัวอย่างของการบูรณาการแนวคิดจากหลายสาขาวิชา ทั้ง **วิศวกรรมซอฟต์แวร์ (Software Engineering)**, **การออกแบบเชิงวัตถุ (Object-oriented Design)** และ **การประมวลผลเชิงฟังก์ชัน (Functional Paradigm)** ผ่านกลไกของ Component, Props และ State ซึ่งสะท้อนหลักการของ “การแยกความรับผิดชอบ” (Separation of Concerns) และ “การห่อหุ้มข้อมูล” (Encapsulation) บทนี้จึงมุ่งหมายให้ผู้เรียนเข้าใจว่าแนวคิดเชิงทฤษฎีเหล่านี้ถูกถ่ายทอดและทำงานจริงอย่างไรภายใต้สภาพแวดล้อมของ React Native ทั้งในระดับโครงสร้าง ตรรกะ และพฤติกรรมของโปรแกรม



## **2.2. React Component: หน่วยย่อยของระบบส่วนติดต่อผู้ใช้**

### **2.2.1 ความหมายและบทบาทของ Component**

**Component** คือหน่วยย่อยของส่วนติดต่อผู้ใช้ (UI) ที่ประกอบด้วยโครงสร้าง การแสดงผล และตรรกะของตนเอง
แนวคิดของ Component เปรียบได้กับ “ชิ้นส่วนเล็ก ๆ ของระบบ” ที่สามารถรวมกันเป็นโครงสร้างที่ซับซ้อนกว่า เช่น หน้าจอหลักของแอปพลิเคชัน

ในเชิงการเขียนโปรแกรม Component เป็นฟังก์ชันหรือคลาสที่รับข้อมูลจากภายนอก (Props) และสร้างผลลัพธ์เป็นหน้าตาของ UI ตามหลักการ **UI = f(Data)**

การทำความเข้าใจแนวคิดของ Component ควรเริ่มจากการมองว่า Component ไม่ใช่เพียงโค้ดที่สร้างส่วนหนึ่งของหน้าจอเท่านั้น แต่เป็น “หน่วยของความคิด” (Conceptual Unit) ที่สะท้อนแนวทางของสถาปัตยกรรมซอฟต์แวร์แบบองค์ประกอบ (Component-based Software Architecture) ใน React Native แต่ละ Component ทำหน้าที่เสมือน **ฟังก์ชันทางคณิตศาสตร์** ที่รับข้อมูลเข้ามา (Input) และให้ผลลัพธ์เป็นส่วนติดต่อผู้ใช้ (UI) ตามหลักการ **UI = f(Data)** ซึ่งแสดงถึงแนวคิดเชิงฟังก์ชัน (Functional Programming) ที่ React นำมาใช้

ตัวอย่างโค้ดต่อไปนี้แสดง Component พื้นฐานชื่อ `Welcome`

```jsx
function Welcome() {
  return (
    <Text>ยินดีต้อนรับสู่แอปของเรา!</Text>
  );
}
```

ในมุมมองทางทฤษฎี `Welcome` เป็น **Stateless Functional Component** — กล่าวคือ ไม่มี State ภายในของตนเอง และให้ผลลัพธ์ที่คงที่เสมอเมื่อเรียกใช้งาน การออกแบบเช่นนี้สะท้อนหลักการของ “ความบริสุทธิ์ของฟังก์ชัน” (Functional Purity) ซึ่งช่วยให้โค้ดมีความคาดเดาได้ (Predictable Behavior) และง่ายต่อการทดสอบ (Testability)

เมื่อเรานำ Component `Welcome` ไปประกอบร่วมกับองค์ประกอบอื่น เช่นใน Component `App`

```jsx
function App() {
  return (
    <View>
      <Welcome />
      <Text>เริ่มต้นการใช้งานได้เลย</Text>
    </View>
  );
}
```

เราจะเห็นแนวคิดของ **Composition** หรือ “การประกอบเชิงลำดับชั้น” (Hierarchical Composition) ซึ่งเป็นหัวใจสำคัญของสถาปัตยกรรม React การรวม Component ย่อยหลายตัวเข้าด้วยกันในรูปแบบของ **Component Tree** ทำให้ระบบสามารถขยายขนาดได้โดยไม่สูญเสียความเป็นอิสระของแต่ละส่วน ทั้งยังส่งเสริมหลักการ **Separation of Concerns** — คือการแบ่งหน้าที่ของโค้ดตามบทบาทที่ชัดเจน เช่น การแสดงผล, การจัดการข้อมูล, และการโต้ตอบกับผู้ใช้ นับเป็นพื้นฐานของการพัฒนาแอปที่ยืดหยุ่นและบำรุงรักษาง่ายในระดับสถาปัตยกรรม.

 

### **2.2.3 ลักษณะสำคัญของ Component**

แนวคิดของ **Component** ใน React Native สะท้อนหลักการสำคัญของการออกแบบซอฟต์แวร์เชิงสถาปัตยกรรม (Software Architecture Principles) ซึ่งมุ่งสร้างระบบที่ยืดหยุ่น บำรุงรักษาได้ง่าย และขยายได้ในระยะยาว ลักษณะสำคัญของ Component มีดังนี้


#### **1. Encapsulation (การห่อหุ้มข้อมูลและพฤติกรรม)**

Component ควรเก็บทั้ง “โครงสร้างการแสดงผล” และ “ตรรกะการทำงาน” ไว้ภายในตนเอง โดยไม่เปิดเผยรายละเอียดการทำงานออกไปภายนอก หลักการนี้สอดคล้องกับแนวคิดของ **Information Hiding** และ **Object-oriented Design**

**ตัวอย่าง:**

```jsx
function Counter() {
  const [count, setCount] = useState(0);
  return (
    <View>
      <Text>จำนวน: {count}</Text>
      <Button title="เพิ่ม" onPress={() => setCount(count + 1)} />
    </View>
  );
}
```

Component `Counter` จัดการ State (`count`) ภายในตนเอง ผู้ใช้ภายนอกไม่จำเป็นต้องรู้กลไกการเพิ่มค่า เพียงเรียกใช้งานก็เพียงพอ


#### **2. Reusability (การนำกลับมาใช้ซ้ำได้)**

Component ที่ออกแบบดีสามารถนำไปใช้ซ้ำในหลายบริบทได้ เพียงเปลี่ยนข้อมูลที่ส่งเข้า (Props)

```jsx
function Welcome(props) {
  return <Text>สวัสดี {props.name}</Text>;
}

<View>
  <Welcome name="นักศึกษา" />
  <Welcome name="อาจารย์" />
</View>
```

หลักการนี้สะท้อนแนวคิดของ **Parametric Polymorphism** — การสร้างพฤติกรรมที่เปลี่ยนแปลงได้ตามข้อมูลนำเข้า


#### **3. Composition (การประกอบเป็นโครงสร้างใหญ่)**

Component สามารถรวมกันเป็น “ต้นไม้ของ UI” (Component Tree) เพื่อสร้างระบบขนาดใหญ่ขึ้น

```jsx
function App() {
  return (
    <View>
      <Header />
      <Content />
      <Footer />
    </View>
  );
}
```

แนวคิดนี้คล้ายกับการออกแบบระบบเชิงโมดูล (Modular System) ที่แยกแต่ละส่วนให้รับผิดชอบเฉพาะด้าน แต่สามารถทำงานร่วมกันได้อย่างเป็นเอกภาพ


#### **4. Maintainability (ความง่ายต่อการบำรุงรักษา)**

เมื่อแต่ละ Component แยกความรับผิดชอบชัดเจน นักพัฒนาสามารถแก้ไขหรือปรับปรุงส่วนใดส่วนหนึ่งได้โดยไม่กระทบส่วนอื่น หลักการนี้สอดคล้องกับ **Separation of Concerns (SoC)** ซึ่งเป็นรากฐานของการออกแบบซอฟต์แวร์สมัยใหม่

โดยสรุป React Component เป็นการนำหลักการทางทฤษฎี เช่น Encapsulation, Modularity, และ Reusability มาประยุกต์ใช้อย่างเป็นรูปธรรม เพื่อสร้างระบบ UI ที่มีโครงสร้างยั่งยืน และรองรับการเปลี่ยนแปลงได้ในระยะยาว.



## **2.3. JSX Syntax: ภาษากลางระหว่างตรรกะและโครงสร้าง**

### **2.3.1 แนวคิดพื้นฐานของ JSX**

**JSX (JavaScript XML)** คือภาษาขยาย (Syntax Extension) ที่ถูกออกแบบมาเพื่อให้การเขียนส่วนติดต่อผู้ใช้ (UI) มีลักษณะเป็นธรรมชาติและอ่านง่ายกว่า JavaScript ปกติ JSX ไม่ใช่ภาษาใหม่ แต่เป็นรูปแบบการเขียนที่ช่วยให้นักพัฒนาสามารถ “อธิบายโครงสร้างของ UI” ภายในโค้ดโปรแกรมโดยตรง

ในเชิงทฤษฎี JSX สะท้อนแนวคิดของ **Declarative Programming** ซึ่งมุ่งเน้น “การอธิบายสิ่งที่ต้องการให้ระบบแสดงผล” มากกว่าการ “สั่งให้ระบบทำงานตามลำดับขั้นตอน” นักพัฒนาเพียงระบุว่า UI ควรมีหน้าตาเป็นอย่างไร เมื่อข้อมูล (State) เปลี่ยน ระบบจะอัปเดตการแสดงผลให้ตรงกับสถานะปัจจุบันโดยอัตโนมัติ

แนวคิดนี้ต่างจากการเขียนโปรแกรมเชิงคำสั่ง (Imperative Programming) ซึ่งนักพัฒนาต้องกำหนดขั้นตอนอย่างละเอียด เช่น วาดปุ่ม → กำหนดสี → เพิ่มข้อความ → ผูกเหตุการณ์ ใน JSX เพียงบอกว่าต้องการ “ปุ่มที่แสดงข้อความนี้” ระบบจะสร้างสิ่งนั้นให้เอง ซึ่งสะท้อนหลักการของ **Data-driven Rendering** ที่มุ่งให้ข้อมูลเป็นตัวกำหนดสภาพของส่วนติดต่อผู้ใช้ทั้งหมด

### **2.3.2 โครงสร้างของ JSX**

พิจารณาตัวอย่างโค้ดต่อไปนี้:

```jsx
function Greeting() {
  const user = "สมชาย";
  return (
    <View>
      <Text>สวัสดี {user}</Text>
    </View>
  );
}
```

**การวิเคราะห์เชิงทฤษฎี:**

1. **แท็ก `<View>` และ `<Text>`** ทำหน้าที่คล้าย “คอนเทนเนอร์” (Container) และ “องค์ประกอบการแสดงผล” (UI Element) ของ React Native ซึ่งถูกแมป (Mapped) ไปยังองค์ประกอบของระบบปฏิบัติการจริง เช่น `UIView` ของ iOS หรือ `ViewGroup` ของ Android
2. **เครื่องหมายปีกกา `{}`** ใช้ฝังค่าตัวแปรหรือผลลัพธ์ของนิพจน์ JavaScript ลงใน JSX สะท้อนหลักการของ “การผสานตรรกะเข้ากับโครงสร้าง” (Logic-View Integration)
3. JSX ที่เขียนไว้จะถูกคอมไพล์โดยเครื่องมือ Babel ให้กลายเป็นคำสั่ง JavaScript ที่สร้างโครงสร้างวัตถุ (Virtual DOM หรือ Virtual UI Tree) เพื่อให้ React จัดการการแสดงผลอย่างมีประสิทธิภาพ

ดังนั้น JSX จึงทำหน้าที่เป็น “ภาษากลาง” ระหว่างแนวคิดเชิงโครงสร้าง (Structural Thinking) และแนวคิดเชิงตรรกะ (Logical Thinking) ซึ่งเป็นจุดแข็งที่ทำให้ React Native สามารถพัฒนา UI ที่ซับซ้อนได้โดยไม่สูญเสียความเข้าใจ

### **2.3.3 ข้อดีของ JSX ในเชิงทฤษฎี**

| ประเด็น                                             | คำอธิบายเชิงทฤษฎี                                                                                                                                  |
| --------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------- |
| **อ่านง่าย (Readability)**                          | โครงสร้างของ JSX คล้ายกับโครงสร้าง UI จริง ทำให้นักพัฒนาเข้าใจความสัมพันธ์ของส่วนต่าง ๆ ได้ง่ายกว่าการใช้คำสั่ง DOM แบบเดิม                        |
| **ผสานตรรกะและโครงสร้าง (Logic Integration)**       | JSX อนุญาตให้ใช้ตัวแปร เงื่อนไข และฟังก์ชันภายในโครงสร้าง UI ได้โดยตรง สอดคล้องกับแนวคิดของการเขียนโปรแกรมแบบ Reactive ที่ UI เป็นผลลัพธ์ของข้อมูล |
| **ส่งเสริมการคิดเชิงประกาศ (Declarative Thinking)** | JSX ลดความจำเป็นในการอธิบายขั้นตอนที่ระบบต้องทำทีละขั้น ทำให้โฟกัสกับสิ่งที่ต้องการแสดงมากกว่ากระบวนการที่จะไปถึงผลลัพธ์นั้น                       |

ในเชิงวิศวกรรมซอฟต์แวร์ JSX ช่วยให้โค้ดมี **Cognitive Simplicity** — คือ ความเรียบง่ายต่อการรับรู้ของมนุษย์ (Human Cognitive Load) ซึ่งเป็นหัวใจของการออกแบบภาษาที่ดีและช่วยลดข้อผิดพลาดในกระบวนการพัฒนา


### **2.3.4 ตัวอย่างเงื่อนไขเชิง Declarative**

โค้ดต่อไปนี้แสดงแนวคิดของการใช้ **เงื่อนไข (Conditional Rendering)** ใน JSX เพื่อสร้าง UI ที่ตอบสนองต่อสถานะของข้อมูลโดยอัตโนมัติ

```jsx
<View>
  {isLoggedIn ? <Text>ยินดีต้อนรับกลับ</Text> : <Text>กรุณาเข้าสู่ระบบ</Text>}
</View>
```

**การอธิบายเชิงแนวคิด:**
ในกรณีนี้ JSX ใช้ตัวดำเนินการเงื่อนไข `? :` เพื่อเลือกองค์ประกอบที่จะปรากฏบนหน้าจอ โดยพิจารณาจากค่าของตัวแปร `isLoggedIn` ซึ่งอาจเป็น State ภายใน Component หรือข้อมูลที่รับมาจาก Props

ระบบจะไม่ต้องรับคำสั่ง “ซ่อน” หรือ “แสดง” องค์ประกอบอย่างเชิงขั้นตอน แต่จะ “เลือกแสดงผล” ตามสถานะของข้อมูลที่กำหนดไว้ ซึ่งสะท้อนหลักการของ **Reactive UI Rendering** — การสร้างส่วนติดต่อผู้ใช้ที่ตอบสนองต่อข้อมูลแบบอัตโนมัติ

แนวทางนี้ช่วยให้โค้ดมีความกระชับ (Concise), เข้าใจง่าย (Readable), และสอดคล้องกับหลักการออกแบบเชิงประกาศ (Declarative Design Principle) อันเป็นหัวใจสำคัญของ React และ React Native ทั้งในระดับแนวคิดและการปฏิบัติจริง.



## **2.4. Props & State: กลไกข้อมูลของ React Component**

### **2.4.1 Props (Properties)**

**Props** (ย่อมาจาก *Properties*) คือกลไกพื้นฐานในการส่งข้อมูลจากภายนอกเข้าสู่ Component เพื่อกำหนดลักษณะการทำงานหรือการแสดงผลของ Component นั้น ๆ ในเชิงสถาปัตยกรรม Props ทำหน้าที่เป็น “ช่องทางการสื่อสารทางเดียว” (Unidirectional Data Flow) ระหว่าง Component ที่อยู่ในระดับต่าง ๆ ของโครงสร้างต้นไม้ (Component Tree)

React ออกแบบให้การส่งข้อมูลเป็นแบบ *Top-down Flow* หมายถึง ข้อมูลไหลจาก **Component แม่ (Parent)** ไปยัง **Component ลูก (Child)** เท่านั้น โดยไม่มีการส่งย้อนกลับขึ้นไปข้างบน แนวคิดนี้ช่วยให้ระบบมีความคาดเดาได้ง่าย (Predictable State) และลดปัญหาการซ้ำซ้อนของข้อมูล ซึ่งมักเกิดขึ้นในระบบที่ข้อมูลไหลหลายทิศทาง

ตัวอย่างต่อไปนี้แสดงโครงสร้างการใช้ Props ในการสื่อสารระหว่าง Component:

```jsx
function Welcome(props) {
  return <Text>สวัสดี {props.name}</Text>;
}

function App() {
  return <Welcome name="นักศึกษา" />;
}
```

**การวิเคราะห์เชิงหลักการ:**

* `App` ทำหน้าที่เป็น Component แม่ที่ส่งค่า `name` ไปยัง `Welcome`
* `Welcome` เป็น Component ลูกที่ “แสดงผล” ตามค่าที่ได้รับจาก `props` โดยไม่สามารถเปลี่ยนค่าได้
* เมื่อค่าที่ส่งจากแม่เปลี่ยน (เช่น `name="อาจารย์"`), ระบบจะ render ใหม่โดยอัตโนมัติ

ในเชิงทฤษฎี Props สะท้อนแนวคิดของ **Functional Programming** ที่ว่า *“ผลลัพธ์ของฟังก์ชันขึ้นอยู่กับข้อมูลนำเข้า”* — กล่าวคือ ถ้า Input เดียวกัน จะให้ผลลัพธ์เหมือนเดิมเสมอ (Pure Function Behavior) ซึ่งเป็นหัวใจของ React Component ที่ไม่ขึ้นกับสถานะภายใน

Props ยังสอดคล้องกับหลักการของ **Immutability (ข้อมูลไม่เปลี่ยนแปลง)** เนื่องจาก Component ลูกไม่สามารถแก้ไข Props ได้โดยตรง การออกแบบเช่นนี้ช่วยให้การควบคุมข้อมูลในระบบเป็นไปอย่างชัดเจนและปลอดภัย ส่งผลให้ React สามารถจัดการการอัปเดต UI ได้อย่างมีประสิทธิภาพ และลดความซับซ้อนของโครงสร้างข้อมูลภายในระบบในระยะยาว.

### **2.4.2 State**

**State** คือ “ข้อมูลภายในของ Component” ซึ่งสามารถเปลี่ยนแปลงได้ตลอดระยะเวลาการทำงานของโปรแกรม State ทำหน้าที่เป็นตัวแทนของ “สถานะ (Condition)” ของส่วนติดต่อผู้ใช้ (UI) ณ ช่วงเวลาใดเวลาหนึ่ง ในเชิงแนวคิด State คือส่วนหนึ่งของ **Dynamic Data Model** ที่มีความสัมพันธ์โดยตรงกับลักษณะการแสดงผลของ Component

ต่างจาก **Props** ซึ่งเป็นข้อมูลจากภายนอกและไม่สามารถแก้ไขได้โดยตรง State เป็นข้อมูลที่ Component สามารถควบคุมได้ด้วยตนเอง และเมื่อมีการเปลี่ยนแปลงค่าใน State React จะทำกระบวนการ **Re-rendering** ใหม่โดยอัตโนมัติ เพื่อให้ส่วนติดต่อผู้ใช้สะท้อนค่าล่าสุดของข้อมูลอย่างสอดคล้อง ซึ่งเรียกว่าแนวคิด **State-driven Rendering**


**ตัวอย่างโค้ดเชิงแนวคิด:**

```jsx
function Counter() {
  const [count, setCount] = useState(0);

  return (
    <View>
      <Text>จำนวน: {count}</Text>
      <Button title="เพิ่มค่า" onPress={() => setCount(count + 1)} />
    </View>
  );
}
```


**การวิเคราะห์เชิงทฤษฎี:**

* ฟังก์ชัน `useState(0)` เป็นกลไกของ React สำหรับการสร้าง “ตัวแปรสถานะ” และ “ฟังก์ชันเปลี่ยนค่า” ซึ่งสะท้อนแนวคิดของ *Stateful Function Component*
* เมื่อผู้ใช้กดปุ่ม `Button` จะเรียกใช้ฟังก์ชัน `setCount` เพื่อเปลี่ยนค่าของ State จาก `0` เป็น `1`, `2`, `3` ตามลำดับ
* React ตรวจพบการเปลี่ยนแปลงของ State และทำการ **Reconciliation** เพื่อสร้าง “Virtual UI Tree” ใหม่ แล้วเปรียบเทียบกับของเดิม (ผ่านกระบวนการ Diffing Algorithm) เพื่ออัปเดตเฉพาะส่วนที่เปลี่ยนจริงบนหน้าจอ


ในเชิงสถาปัตยกรรม **State คือศูนย์กลางของพฤติกรรมแบบ Reactive System** — กล่าวคือ UI ไม่ได้ถูกควบคุมโดยคำสั่ง (Imperative Commands) แต่ถูกขับเคลื่อนด้วยข้อมูล (Data-driven Behavior) ซึ่งเป็นรากฐานของแนวคิด **Reactive Programming** ที่ React Native นำมาใช้ เพื่อสร้างส่วนติดต่อผู้ใช้ที่ตอบสนองอย่างชาญฉลาดและมีประสิทธิภาพสูง.


### **2.4.3 ความแตกต่างระหว่าง Props และ State**
 
 

ในสถาปัตยกรรมของ React และ React Native ข้อมูลภายในระบบแบ่งออกเป็นสองลักษณะหลัก ได้แก่ **Props** และ **State** ซึ่งแม้จะมีหน้าที่คล้ายกันในการควบคุมพฤติกรรมของ Component แต่มี “แหล่งที่มา” และ “กลไกการเปลี่ยนแปลง” ที่แตกต่างกันโดยสิ้นเชิง ความเข้าใจความแตกต่างนี้เป็นสิ่งสำคัญ เนื่องจากเป็นพื้นฐานของแนวคิด **Unidirectional Data Flow** หรือ “การไหลของข้อมูลทางเดียว” ซึ่งเป็นหัวใจของระบบ React

| ประเด็น            | Props                                     | State                                                    |
| ------------------ | ----------------------------------------- | -------------------------------------------------------- |
| **แหล่งข้อมูล**    | ข้อมูลจากภายนอก ส่งจาก Component อื่น     | ข้อมูลภายในของ Component เอง                             |
| **การเปลี่ยนแปลง** | ไม่สามารถเปลี่ยนได้โดยตรง (Immutable)     | สามารถเปลี่ยนแปลงได้ระหว่างการทำงาน                      |
| **จุดประสงค์**     | ใช้กำหนดค่าคงที่หรือพฤติกรรมของ Component | ใช้เก็บค่าที่เปลี่ยนตามเหตุการณ์ เช่น input หรือ counter |
| **การอัปเดต UI**   | ไม่ทำให้เกิดการ render ใหม่โดยตรง         | กระตุ้นให้ระบบ render ใหม่โดยอัตโนมัติเมื่อค่าเปลี่ยน    |

---

ในเชิงแนวคิด **Props** ทำหน้าที่คล้ายกับ “พารามิเตอร์ของฟังก์ชัน” (Function Parameters) ซึ่งทำให้ Component สามารถรับข้อมูลจากภายนอกและสร้างผลลัพธ์ตามที่ได้รับโดยไม่เปลี่ยนค่าดังกล่าว ขณะที่ **State** ทำหน้าที่เหมือน “ตัวแปรภายใน (Local Variable)” ของ Component ที่สามารถเปลี่ยนได้ตลอดเวลาและส่งผลโดยตรงต่อการแสดงผลของ UI

แนวทางนี้สะท้อนหลักการของ **Functional Programming** ที่ว่า *“UI เป็นฟังก์ชันของข้อมูล (UI = f(Data))”* ซึ่งในกรณีของ React, ข้อมูลนี้อาจมาจาก Props (input คงที่) หรือ State (ค่าที่เปลี่ยนแปลงได้) เมื่อ State เปลี่ยน ระบบจะสร้าง **Virtual DOM (หรือ Virtual UI Tree)** ใหม่เพื่อเปรียบเทียบกับของเดิม แล้วอัปเดตเฉพาะส่วนที่ต่าง (ผ่าน Diffing Algorithm) เพื่อให้ได้การแสดงผลที่มีประสิทธิภาพสูงโดยไม่ต้อง render ทั้งหมด

ดังนั้น Props และ State จึงทำงานร่วมกันอย่างสอดคล้องในฐานะ “กลไกขับเคลื่อนข้อมูลของระบบ” — Props ควบคุมการกำหนดค่า ส่วน State ควบคุมพฤติกรรมที่เปลี่ยนแปลง ช่วยให้ React Native สามารถสร้าง UI ที่ตอบสนองต่อข้อมูลอย่างชาญฉลาดและเป็นระเบียบภายใต้หลักการของการเขียนโปรแกรมเชิงประกาศ (Declarative Programming).

ยอดเยี่ยมครับ — ด้านล่างนี้คือ **ฉบับขยายเชิงตำรา (ความยาว ~350 คำ)** สำหรับหัวข้อ
**“2.5 การติดตั้งและรันโปรเจกต์ด้วย Expo”**
ซึ่งอธิบายเชิงทฤษฎีถึงกลไกภายในของ Expo, แนวคิด Abstraction Layer, และกระบวนการทำงานเชิงสถาปัตยกรรมของระบบ React Native + Expo พร้อมโยงเข้ากับหลักการทางวิศวกรรมซอฟต์แวร์

---

## **2.5 การติดตั้งและรันโปรเจกต์ด้วย Expo**

### **2.5.1 Expo คืออะไร**

**Expo** คือสภาพแวดล้อมการทำงาน (*Runtime Environment*) และเครื่องมือพัฒนาแบบครบวงจร (Development Framework) ที่ถูกออกแบบมาเพื่ออำนวยความสะดวกแก่นักพัฒนา React Native โดยเฉพาะ จุดเด่นของ Expo คือช่วยให้ผู้เรียนหรือผู้พัฒนาเริ่มสร้างแอปพลิเคชันได้ทันที **โดยไม่จำเป็นต้องติดตั้ง Native SDK** ของ Android หรือ iOS ซึ่งโดยปกติจะต้องใช้เวลาในการตั้งค่าที่ซับซ้อนมาก

ในเชิงทฤษฎี Expo ทำหน้าที่เป็น **Abstraction Layer** หรือ “ชั้นนามธรรม” ระหว่างโค้ดภาษา JavaScript ที่นักพัฒนาเขียน กับระบบปฏิบัติการระดับล่างของอุปกรณ์ (Native Layer) ชั้นนี้ทำหน้าที่ซ่อนรายละเอียดเชิงเทคนิค เช่น การจัดการหน่วยความจำ การเข้าถึงฮาร์ดแวร์ และการคอมไพล์ Native Code เพื่อให้ผู้พัฒนาสามารถโฟกัสกับตรรกะและการออกแบบเชิงโครงสร้างของโปรแกรมมากกว่าเรื่องการตั้งค่าระบบ

นอกจากนี้ Expo ยังมี **API มาตรฐาน (Unified API)** ที่ช่วยให้การเข้าถึงคุณสมบัติของอุปกรณ์ เช่น กล้อง, GPS, การสั่น, การแจ้งเตือน หรือการเชื่อมต่ออินเทอร์เน็ต ทำได้โดยไม่ต้องเขียนโค้ดเฉพาะแพลตฟอร์ม (Platform-specific Code) ทำให้เกิดหลักการสำคัญของการพัฒนาแบบ **Cross-platform Abstraction** ซึ่งเป็นหัวใจของ React Native ในการลดความแตกต่างระหว่างระบบปฏิบัติการ


### **2.5.2 กระบวนการทำงานของ Expo**

| ขั้นตอน                                              | คำอธิบายเชิงแนวคิด                                                                                                                                                                                                                                 |
| ---------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **1. สร้างโปรเจกต์ (Project Initialization)**        | Expo CLI ทำหน้าที่สร้างโครงสร้างของโปรแกรมเบื้องต้น โดยกำหนดไฟล์หลัก เช่น `App.js`, โฟลเดอร์ `assets/` และ `package.json` ซึ่งทำหน้าที่เป็น Metadata ของโปรเจกต์                                                                                   |
| **2. รันแอปใน Expo Go**                              | ผู้พัฒนาสามารถทดสอบแอปผ่านแอปพลิเคชัน “Expo Go” บนสมาร์ตโฟน ซึ่งทำหน้าที่เป็นตัวจำลอง (Simulator) ที่โหลดและรันโค้ด JavaScript แบบเรียลไทม์ผ่านเครือข่ายเดียวกัน                                                                                   |
| **3. การสื่อสารระหว่าง JavaScript และ Native Layer** | Expo ทำหน้าที่เป็น **Bridge (สะพาน)** ที่แปลงคำสั่งจาก JavaScript ให้กลายเป็นการเรียกใช้งานฟังก์ชันของระบบปฏิบัติการ เช่น การเปิดกล้องหรือการบันทึกเสียง หลักการนี้เรียกว่า **Bridge Communication Model** ซึ่งเป็นสถาปัตยกรรมหลักของ React Native |
| **4. การ Build แอป (Build Process)**                 | เมื่อพัฒนาเสร็จ Expo จะใช้ระบบ Build Server เพื่อสร้างไฟล์ติดตั้ง (เช่น `.apk` สำหรับ Android หรือ `.ipa` สำหรับ iOS) โดยอัตโนมัติ ลดภาระจากการใช้เครื่องมือ Native เช่น Android Studio หรือ Xcode                                                 |

 
### **การวิเคราะห์เชิงทฤษฎี**

Expo เป็นตัวอย่างของการออกแบบระบบที่ใช้แนวคิด **Layered Architecture** และ **Abstraction Principle** เพื่อจัดการความซับซ้อนของเทคโนโลยีระดับล่างให้เรียบง่ายในระดับผู้ใช้ ระบบลักษณะนี้ยังสะท้อนหลักการทางวิศวกรรมซอฟต์แวร์ที่เรียกว่า **Separation of Concerns (SoC)** ซึ่งแบ่งหน้าที่ของแต่ละส่วนให้ชัดเจนระหว่าง “การประมวลผลตรรกะของแอป” กับ “การสื่อสารกับฮาร์ดแวร์” ผลลัพธ์คือสภาพแวดล้อมการพัฒนาที่มีประสิทธิภาพสูง เรียบง่าย และเปิดโอกาสให้ผู้เรียนสามารถเข้าใจแนวคิดของ React Native ได้อย่างลึกซึ้งโดยไม่ต้องพึ่งพาเครื่องมือเฉพาะแพลตฟอร์ม.

 

### **2.5.3 ตัวอย่างโครงสร้างโปรเจกต์**

เมื่อเริ่มต้นพัฒนาแอปพลิเคชันด้วย **Expo CLI**, ระบบจะสร้างโครงสร้างโปรเจกต์พื้นฐานที่เป็นมาตรฐานของสถาปัตยกรรม React Native ดังนี้

```
/MyApp
 ├── App.js
 ├── package.json
 ├── assets/
 └── components/
```

โครงสร้างนี้ไม่เพียงสะท้อนรูปแบบการจัดเก็บไฟล์เท่านั้น แต่ยังแสดงถึงแนวคิดของ **Modular Design** และ **Component-based Architecture** ดังนี้:

* **`App.js`** — เป็นจุดเริ่มต้นของโปรแกรม (Entry Point) ที่ทำหน้าที่เป็น *Root Component* หรือ Component หลักของระบบ ซึ่งควบคุมลำดับการแสดงผลของส่วนอื่น ๆ ทั้งหมดภายในแอป คล้ายกับฟังก์ชัน `main()` ในภาษาระดับล่าง เช่น C หรือ Java
* **`package.json`** — ทำหน้าที่เป็น *Metadata File* ของโปรเจกต์ ซึ่งบันทึกข้อมูลสำคัญ เช่น ชื่อโปรแกรม เวอร์ชัน ไลบรารีที่ใช้ และสคริปต์สำหรับการรันแอป ถือเป็นส่วนหนึ่งของ **Configuration Management**
* **`assets/`** — เก็บทรัพยากรที่ไม่ใช่โค้ด เช่น รูปภาพ เสียง หรือวิดีโอ ซึ่งใช้ร่วมกันระหว่าง Component หลายตัว
* **`components/`** — เป็นพื้นที่สำหรับจัดเก็บ Component ย่อย ๆ ที่ถูกสร้างขึ้นตามหลัก **Separation of Concerns (SoC)** เพื่อให้โค้ดมีความชัดเจนและบำรุงรักษาได้ง่าย

โครงสร้างนี้ช่วยสร้างมาตรฐานในการจัดการความซับซ้อน (Complexity Management) และส่งเสริมหลักการ **Scalability** หรือความสามารถในการขยายระบบในอนาคต

 

### **2.5.4 ตัวอย่างการเขียนโปรแกรมด้วย Expo**

เมื่อสร้างโปรเจกต์แล้ว React Native จะเริ่มทำงานจากไฟล์ `App.js` ซึ่งทำหน้าที่เป็น Component หลัก ตัวอย่างโปรแกรมต่อไปนี้แสดงโครงสร้างพื้นฐานของแอป React Native ที่ทำงานผ่าน Expo:

```jsx
import { Text, View } from 'react-native';

export default function App() {
  return (
    <View>
      <Text>สวัสดี React Native!</Text>
    </View>
  );
}
```

**การวิเคราะห์เชิงหลักการ:**

1. คำสั่ง `import` ดึง Component มาตรฐานจากไลบรารี `react-native` เช่น `View` (โครงสร้างภายนอก) และ `Text` (องค์ประกอบข้อความ) ซึ่งถูกแมปไปยัง Native Component ของระบบปฏิบัติการจริง
2. ฟังก์ชัน `App()` ทำหน้าที่เป็น **Functional Component** ที่คืนค่า JSX เพื่อบอกระบบว่า “UI ควรมีหน้าตาอย่างไร” ตามแนวคิด **Declarative Programming**
3. คำสั่ง `export default` กำหนดให้ Component นี้เป็นจุดเริ่มต้นของแอป ซึ่ง Expo จะเรียกใช้โดยอัตโนมัติเมื่อรันโปรแกรม

เมื่อรันโปรแกรมผ่าน **Expo Go Application** บนสมาร์ตโฟนหรือ Emulator, Expo จะโหลดและประมวลผลโค้ด JavaScript แบบเรียลไทม์ แล้วแปลงผลลัพธ์ให้เป็น Native UI ผ่านกระบวนการที่เรียกว่า **Bridge Rendering** หรือ “การแปลคำสั่งระหว่างชั้น”

การออกแบบระบบในลักษณะนี้สะท้อนหลักการทางสถาปัตยกรรมซอฟต์แวร์ที่ว่า **“Abstraction Simplifies Interaction”** — ชั้นนามธรรม (Expo) ทำให้ผู้พัฒนาสามารถสื่อสารกับระบบที่ซับซ้อนได้อย่างง่ายดาย โดยไม่ต้องจัดการกับรายละเอียดระดับฮาร์ดแวร์โดยตรง ทั้งหมดนี้คือหัวใจของแนวคิด “พัฒนาได้เร็ว เข้าใจง่าย และขยายได้ในระยะยาว” ที่ React Native และ Expo ร่วมกันนำเสนอ.


 

## **2.6 บทสรุปแนวคิด**

React Native เป็นตัวอย่างสำคัญของเทคโนโลยีที่ผสานแนวคิดเชิงทฤษฎีของการออกแบบซอฟต์แวร์เข้ากับการพัฒนาโปรแกรมจริงได้อย่างมีประสิทธิภาพ โดยเฉพาะการนำแนวคิด **Component-based Architecture**, **Declarative Programming**, **State-driven Rendering**, และ **Unidirectional Data Flow** มาประยุกต์ใช้อย่างเป็นระบบ ส่งผลให้กระบวนการพัฒนาแอปพลิเคชันมีความเป็นระเบียบ เข้าใจง่าย และยืดหยุ่นต่อการเปลี่ยนแปลงในอนาคต

| แนวคิดเชิงหลักการ                | การปรากฏในโค้ด React Native                                                                            |
| -------------------------------- | ------------------------------------------------------------------------------------------------------ |
| **Component-based Architecture** | การแบ่ง UI ออกเป็นส่วนย่อย (Component) ที่จัดการได้อิสระและสามารถประกอบรวมกันเป็นระบบใหญ่              |
| **Declarative Programming**      | การใช้ JSX เพื่อบอกลักษณะของ UI โดยไม่ต้องระบุขั้นตอนการสร้างอย่างละเอียด                              |
| **State-driven Rendering**       | UI ปรับปรุงอัตโนมัติเมื่อข้อมูลใน State เปลี่ยน สะท้อนหลัก “Data-driven Interface”                     |
| **Unidirectional Data Flow**     | การส่งข้อมูลผ่าน Props จาก Component แม่ไปยังลูกในทิศทางเดียว ช่วยควบคุมความซับซ้อน                    |
| **Abstraction Layer**            | การใช้ Expo เป็นชั้นนามธรรม (Middleware) ที่เชื่อมโลกของ JavaScript กับ Native Layer ของระบบปฏิบัติการ |

แนวคิดเหล่านี้ไม่ได้จำกัดอยู่เฉพาะการพัฒนาแอปมือถือเท่านั้น แต่ยังสะท้อนหลักการทั่วไปของ **Software Architecture** ที่ใช้ในระบบซอฟต์แวร์ทุกประเภท เช่น การแยกหน้าที่ (Separation of Concerns), การห่อหุ้ม (Encapsulation), และการจัดการข้อมูลแบบทิศทางเดียว (Data Flow Control)

ดังนั้น React Native จึงไม่ใช่เพียงเครื่องมือสร้างแอป แต่เป็น “กรณีศึกษาเชิงแนวคิด” ที่แสดงให้เห็นว่าหลักการทางทฤษฎี เช่น Declarative UI, Componentization และ Abstraction สามารถกลายเป็นรูปธรรมในระดับการเขียนโปรแกรมจริงได้อย่างลงตัว เป็นตัวอย่างของการออกแบบเชิงระบบที่ผสมผสานความงามทางวิศวกรรมกับประสิทธิภาพทางปฏิบัติ — จุดเชื่อมระหว่าง “แนวคิด” และ “การสร้างสรรค์ซอฟต์แวร์ที่ใช้งานได้จริง” ในยุคดิจิทัลปัจจุบัน.
