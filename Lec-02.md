
# **บทที่ 2 การเขียนโปรแกรม React Native เบื้องต้น**


## **2.1. บทนำ**

การพัฒนาแอปพลิเคชันในยุคดิจิทัลปัจจุบันกำลังเปลี่ยนผ่านจากแนวทางการเขียนโปรแกรมแบบดั้งเดิม ไปสู่แนวทางที่ให้ความสำคัญกับ “สถาปัตยกรรมซอฟต์แวร์เชิงองค์ประกอบ” (Component-based Software Architecture) และ “การเขียนโปรแกรมเชิงประกาศ” (Declarative Programming) ซึ่งเน้นการอธิบายผลลัพธ์ของระบบ มากกว่าการระบุขั้นตอนการทำงานอย่างละเอียด React Native เป็นหนึ่งในแพลตฟอร์มที่สะท้อนแนวคิดเหล่านี้ได้อย่างชัดเจน โดยนำหลักการของ React มาประยุกต์ใช้ในบริบทของอุปกรณ์พกพา เพื่อสร้างส่วนติดต่อผู้ใช้ (User Interface) ที่ตอบสนองต่อการเปลี่ยนแปลงของข้อมูลได้แบบพลวัต (Dynamic UI Behavior)

ในเชิงทฤษฎี React Native เป็นตัวอย่างของการบูรณาการแนวคิดจากหลายสาขาวิชา ทั้ง **วิศวกรรมซอฟต์แวร์ (Software Engineering)**, **การออกแบบเชิงวัตถุ (Object-oriented Design)** และ **การประมวลผลเชิงฟังก์ชัน (Functional Paradigm)** ผ่านกลไกของ Component, Props และ State ซึ่งสะท้อนหลักการของ “การแยกความรับผิดชอบ” (Separation of Concerns) และ “การห่อหุ้มข้อมูล” (Encapsulation) บทนี้จึงมุ่งหมายให้ผู้เรียนเข้าใจว่าแนวคิดเชิงทฤษฎีเหล่านี้ถูกถ่ายทอดและทำงานจริงอย่างไรภายใต้สภาพแวดล้อมของ React Native ทั้งในระดับโครงสร้าง ตรรกะ และพฤติกรรมของโปรแกรม



## **2.2. React Component: หน่วยย่อยของระบบส่วนติดต่อผู้ใช้**


### **2.2.1 ความหมายและบทบาทของ Component**

**Component** คือหน่วยย่อยของส่วนติดต่อผู้ใช้ (UI) ที่ประกอบด้วยโครงสร้าง การแสดงผล และตรรกะของตนเอง
แนวคิดของ Component เปรียบได้กับ “ชิ้นส่วนเล็ก ๆ ของระบบ” ที่สามารถรวมกันเป็นโครงสร้างที่ซับซ้อนกว่า เช่น หน้าจอหลักของแอปพลิเคชัน

ในเชิงการเขียนโปรแกรม Component เป็นฟังก์ชันหรือคลาสที่รับข้อมูลจากภายนอก (Props) และสร้างผลลัพธ์เป็นหน้าตาของ UI ตามหลักการ **UI = f(Data)**

การทำความเข้าใจแนวคิดของ Component ควรเริ่มจากการมองว่า Component ไม่ใช่เพียงโค้ดที่สร้างส่วนหนึ่งของหน้าจอเท่านั้น แต่เป็น “หน่วยของความคิด” (Conceptual Unit) ที่สะท้อนแนวทางของสถาปัตยกรรมซอฟต์แวร์แบบองค์ประกอบ (Component-based Software Architecture) ใน React Native แต่ละ Component ทำหน้าที่เสมือน **ฟังก์ชันทางคณิตศาสตร์** ที่รับข้อมูลเข้ามา (Input) และให้ผลลัพธ์เป็นส่วนติดต่อผู้ใช้ (UI) ตามหลักการ **UI = f(Data)** ซึ่งแสดงถึงแนวคิดเชิงฟังก์ชัน (Functional Programming) ที่ React นำมาใช้

ตัวอย่างโค้ดต่อไปนี้แสดง Component พื้นฐานชื่อ `Welcome`

```jsx
function Welcome() {
  return (
    <Text>ยินดีต้อนรับสู่แอปของเรา!</Text>
  );
}
```

ในมุมมองทางทฤษฎี `Welcome` เป็น **Stateless Functional Component** — กล่าวคือ ไม่มี State ภายในของตนเอง และให้ผลลัพธ์ที่คงที่เสมอเมื่อเรียกใช้งาน การออกแบบเช่นนี้สะท้อนหลักการของ “ความบริสุทธิ์ของฟังก์ชัน” (Functional Purity) ซึ่งช่วยให้โค้ดมีความคาดเดาได้ (Predictable Behavior) และง่ายต่อการทดสอบ (Testability)

เมื่อเรานำ Component `Welcome` ไปประกอบร่วมกับองค์ประกอบอื่น เช่นใน Component `App`

```jsx
function App() {
  return (
    <View>
      <Welcome />
      <Text>เริ่มต้นการใช้งานได้เลย</Text>
    </View>
  );
}
```

เราจะเห็นแนวคิดของ **Composition** หรือ “การประกอบเชิงลำดับชั้น” (Hierarchical Composition) ซึ่งเป็นหัวใจสำคัญของสถาปัตยกรรม React การรวม Component ย่อยหลายตัวเข้าด้วยกันในรูปแบบของ **Component Tree** ทำให้ระบบสามารถขยายขนาดได้โดยไม่สูญเสียความเป็นอิสระของแต่ละส่วน ทั้งยังส่งเสริมหลักการ **Separation of Concerns** — คือการแบ่งหน้าที่ของโค้ดตามบทบาทที่ชัดเจน เช่น การแสดงผล, การจัดการข้อมูล, และการโต้ตอบกับผู้ใช้ นับเป็นพื้นฐานของการพัฒนาแอปที่ยืดหยุ่นและบำรุงรักษาง่ายในระดับสถาปัตยกรรม.

 

### **2.2.3 ลักษณะสำคัญของ Component**

แนวคิดของ **Component** ใน React Native สะท้อนหลักการสำคัญของการออกแบบซอฟต์แวร์เชิงสถาปัตยกรรม (Software Architecture Principles) ซึ่งมุ่งสร้างระบบที่ยืดหยุ่น บำรุงรักษาได้ง่าย และขยายได้ในระยะยาว ลักษณะสำคัญของ Component มีดังนี้


#### **1. Encapsulation (การห่อหุ้มข้อมูลและพฤติกรรม)**

Component ควรเก็บทั้ง “โครงสร้างการแสดงผล” และ “ตรรกะการทำงาน” ไว้ภายในตนเอง โดยไม่เปิดเผยรายละเอียดการทำงานออกไปภายนอก หลักการนี้สอดคล้องกับแนวคิดของ **Information Hiding** และ **Object-oriented Design**

**ตัวอย่าง:**

```jsx
function Counter() {
  const [count, setCount] = useState(0);
  return (
    <View>
      <Text>จำนวน: {count}</Text>
      <Button title="เพิ่ม" onPress={() => setCount(count + 1)} />
    </View>
  );
}
```

Component `Counter` จัดการ State (`count`) ภายในตนเอง ผู้ใช้ภายนอกไม่จำเป็นต้องรู้กลไกการเพิ่มค่า เพียงเรียกใช้งานก็เพียงพอ


#### **2. Reusability (การนำกลับมาใช้ซ้ำได้)**

Component ที่ออกแบบดีสามารถนำไปใช้ซ้ำในหลายบริบทได้ เพียงเปลี่ยนข้อมูลที่ส่งเข้า (Props)

```jsx
function Welcome(props) {
  return <Text>สวัสดี {props.name}</Text>;
}

<View>
  <Welcome name="นักศึกษา" />
  <Welcome name="อาจารย์" />
</View>
```

หลักการนี้สะท้อนแนวคิดของ **Parametric Polymorphism** — การสร้างพฤติกรรมที่เปลี่ยนแปลงได้ตามข้อมูลนำเข้า


#### **3. Composition (การประกอบเป็นโครงสร้างใหญ่)**

Component สามารถรวมกันเป็น “ต้นไม้ของ UI” (Component Tree) เพื่อสร้างระบบขนาดใหญ่ขึ้น

```jsx
function App() {
  return (
    <View>
      <Header />
      <Content />
      <Footer />
    </View>
  );
}
```

แนวคิดนี้คล้ายกับการออกแบบระบบเชิงโมดูล (Modular System) ที่แยกแต่ละส่วนให้รับผิดชอบเฉพาะด้าน แต่สามารถทำงานร่วมกันได้อย่างเป็นเอกภาพ


#### **4. Maintainability (ความง่ายต่อการบำรุงรักษา)**

เมื่อแต่ละ Component แยกความรับผิดชอบชัดเจน นักพัฒนาสามารถแก้ไขหรือปรับปรุงส่วนใดส่วนหนึ่งได้โดยไม่กระทบส่วนอื่น หลักการนี้สอดคล้องกับ **Separation of Concerns (SoC)** ซึ่งเป็นรากฐานของการออกแบบซอฟต์แวร์สมัยใหม่

โดยสรุป React Component เป็นการนำหลักการทางทฤษฎี เช่น Encapsulation, Modularity, และ Reusability มาประยุกต์ใช้อย่างเป็นรูปธรรม เพื่อสร้างระบบ UI ที่มีโครงสร้างยั่งยืน และรองรับการเปลี่ยนแปลงได้ในระยะยาว.



## **2.3. JSX Syntax: ภาษากลางระหว่างตรรกะและโครงสร้าง**

### **2.3.1 แนวคิดพื้นฐานของ JSX**

**JSX (JavaScript XML)** เป็นภาษาสำหรับเขียนโครงสร้างของส่วนติดต่อผู้ใช้ (UI) โดยมีลักษณะคล้าย XML หรือ HTML แต่ทำงานอยู่ภายในโค้ด JavaScript

ในเชิงแนวคิด JSX สะท้อนหลักการ **Declarative Programming** — คือการ “บอกสิ่งที่ต้องการให้เกิดขึ้น” มากกว่าการ “ระบุขั้นตอนการทำงาน”

### **2.3.2 โครงสร้างของ JSX**

```jsx
function Greeting() {
  const user = "สมชาย";
  return (
    <View>
      <Text>สวัสดี {user}</Text>
    </View>
  );
}
```

**การวิเคราะห์เชิงหลักการ:**

* `<View>` และ `<Text>` คือ “แท็กแสดงผล” ของ React Native (ไม่ใช่ HTML จริง)
* `{user}` เป็นการฝังค่าตัวแปรลงใน JSX
* JSX จะถูกแปลงเป็นคำสั่ง JavaScript ที่บอกระบบว่า “ควรสร้างองค์ประกอบใดบนหน้าจอ”

### **2.3.3 ข้อดีของ JSX ในเชิงทฤษฎี**

| ประเด็น                      | คำอธิบาย                                          |
| ---------------------------- | ------------------------------------------------- |
| **อ่านง่าย**                 | โครงสร้างใกล้เคียงกับ UI จริง                     |
| **ผสานตรรกะและโครงสร้าง**    | สามารถเขียนเงื่อนไขหรือแสดงข้อมูลได้ในบรรทัดเดียว |
| **ส่งเสริมการคิดเชิงประกาศ** | โฟกัสที่ผลลัพธ์มากกว่าขั้นตอน                     |

### **2.3.4 ตัวอย่างเงื่อนไขเชิง Declarative**

```jsx
<View>
  {isLoggedIn ? <Text>ยินดีต้อนรับกลับ</Text> : <Text>กรุณาเข้าสู่ระบบ</Text>}
</View>
```

JSX จะเลือกแสดงผลโดยอัตโนมัติตามค่าของตัวแปร `isLoggedIn`
ไม่ต้องสั่งให้ “ซ่อน” หรือ “แสดง” อย่างในแนวทาง Imperative



## **2.4. Props & State: กลไกข้อมูลของ React Component**

### **2.4.1 Props (Properties)**

**Props** คือ “ข้อมูลนำเข้า” ที่ส่งจากภายนอกเข้าสู่ Component เพื่อกำหนดค่าหรือพฤติกรรมของ Component นั้น ๆ
ในเชิงหลักการ Props เป็นตัวแทนของแนวคิด “การสื่อสารทางเดียว (Unidirectional Data Flow)”

**ตัวอย่าง:**

```jsx
function Welcome(props) {
  return <Text>สวัสดี {props.name}</Text>;
}

function App() {
  return <Welcome name="นักศึกษา" />;
}
```

**การวิเคราะห์เชิงทฤษฎี:**

* `App` คือ Component แม่ (Parent) ที่ส่งข้อมูลผ่าน `name`
* `Welcome` คือ Component ลูก (Child) ที่รับข้อมูลผ่าน `props`
* ข้อมูลไหลจากบนลงล่าง → ลดความซับซ้อนของระบบ


### **2.4.2 State**

**State** คือ “ข้อมูลภายในของ Component” ที่สามารถเปลี่ยนแปลงได้ระหว่างการทำงาน
เมื่อค่าใน State เปลี่ยน React จะ “render ใหม่” เพื่อให้ UI แสดงข้อมูลล่าสุด

**ตัวอย่าง:**

```jsx
function Counter() {
  const [count, setCount] = useState(0);

  return (
    <View>
      <Text>จำนวน: {count}</Text>
      <Button title="เพิ่มค่า" onPress={() => setCount(count + 1)} />
    </View>
  );
}
```

**หลักคิดสำคัญ:**

* `useState` เป็นกลไกที่สร้าง State ภายใน Component
* การเปลี่ยนแปลง State จะกระตุ้นให้ React “ปรับปรุง UI อัตโนมัติ”
* นี่คือการแสดงผลตามสถานะ (State-driven Rendering)

### **2.4.3 ความแตกต่างระหว่าง Props และ State**

| ประเด็น        | Props                               | State                                            |
| -------------- | ----------------------------------- | ------------------------------------------------ |
| แหล่งข้อมูล    | ภายนอก (จาก Component อื่น)         | ภายใน (ของ Component เอง)                        |
| การเปลี่ยนแปลง | ไม่เปลี่ยนแปลงได้โดยตรง             | เปลี่ยนได้ระหว่างการทำงาน                        |
| จุดประสงค์     | ปรับลักษณะหรือค่าคงที่ของ Component | เก็บข้อมูลที่เปลี่ยนแปลง เช่น input หรือ counter |
| การอัปเดต UI   | ไม่กระตุ้นโดยตรง                    | กระตุ้นการ render ใหม่อัตโนมัติ                  |

---

## **2.5. การติดตั้งและรันโปรเจกต์ด้วย Expo**

### **2.5.1 Expo คืออะไร**

**Expo** คือสภาพแวดล้อม (Runtime Environment) ที่ช่วยให้นักพัฒนาสามารถรัน ทดสอบ และดีบัก React Native App ได้ง่ายขึ้น
โดยไม่จำเป็นต้องตั้งค่า Native SDK ของ Android หรือ iOS

ในเชิงหลักการ Expo คือ **Abstraction Layer** ที่ซ่อนความซับซ้อนของระบบระดับล่างไว้เบื้องหลัง API ที่ใช้งานง่าย

### **5.2 กระบวนการทำงานของ Expo**

| ขั้นตอน                                       | คำอธิบายเชิงแนวคิด                              |
| --------------------------------------------- | ----------------------------------------------- |
| 1. สร้างโปรเจกต์                              | สร้างโครงสร้างเริ่มต้นของแอป                    |
| 2. รันแอปใน Expo Go                           | จำลองการทำงานของแอปบนอุปกรณ์จริง                |
| 3. สื่อสารระหว่าง JavaScript และ Native Layer | Expo ทำหน้าที่เป็นสะพาน (Bridge) ระหว่างสองระบบ |
| 4. Build แอป                                  | สร้างไฟล์ติดตั้งที่พร้อมใช้งานจริง              |

### **5.5.3 ตัวอย่างโครงสร้างโปรเจกต์**

```
/MyApp
 ├── App.js
 ├── package.json
 ├── assets/
 └── components/
```

`App.js` คือจุดเริ่มต้นของแอป เป็น Component หลักที่ควบคุมการแสดงผลของส่วนอื่น ๆ

### **5.4 ตัวอย่างการเขียนโปรแกรมด้วย Expo**

```jsx
import { Text, View } from 'react-native';

export default function App() {
  return (
    <View>
      <Text>สวัสดี React Native!</Text>
    </View>
  );
}
```

เมื่อรันผ่าน Expo แอปจะถูกจำลองบนอุปกรณ์หรือ Emulator โดยไม่ต้องคอมไพล์ Native Code เอง

---

## **2.6. บทสรุปแนวคิด**

React Native แสดงให้เห็นถึงความเชื่อมโยงระหว่างแนวคิดเชิงทฤษฎีและการเขียนโปรแกรมจริง

| แนวคิดเชิงหลักการ            | การปรากฏในโค้ด React Native                  |
| ---------------------------- | -------------------------------------------- |
| Component-based Architecture | การแบ่ง UI เป็นหน่วยย่อยที่จัดการได้         |
| Declarative Programming      | การเขียนโค้ดผ่าน JSX                         |
| State-driven Rendering       | UI ปรับอัตโนมัติเมื่อข้อมูลเปลี่ยน           |
| Unidirectional Data Flow     | การส่งข้อมูลผ่าน Props                       |
| Abstraction Layer            | การใช้ Expo เป็นตัวกลางระหว่าง JS กับ Native |

React Native จึงเป็นทั้งเครื่องมือและตัวอย่างทางสถาปัตยกรรมที่แสดงให้เห็นว่า “แนวคิดทางทฤษฎีของการออกแบบซอฟต์แวร์” สามารถกลายเป็น “รูปธรรมที่ใช้งานได้จริง” บนโลกของการพัฒนาแอปพลิเคชันสมัยใหม่

---

ต้องการให้ผม

> 🔹 แปลงเนื้อหานี้เป็น **เอกสารตำราในรูปแบบ `.tex` (LaTeX)**
> หรือ
> 🔹 แปลงเป็น **Marp Markdown (.md)** เพื่อใช้ทำสไลด์สำหรับบรรยาย 60 นาทีดีครับ?
